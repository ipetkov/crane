<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>crane</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A Nix library for building cargo projects.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "ayu";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">crane</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ipetkov/crane" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="crane"><a class="header" href="#crane">Crane</a></h1>
<p>A <a href="https://nixos.org/">Nix</a> library for building <a href="https://doc.rust-lang.org/cargo/">cargo</a> projects.</p>
<ul>
<li><strong>Source fetching</strong>: automatically done using a Cargo.lock file</li>
<li><strong>Incremental</strong>: build your workspace dependencies just once, then quickly lint,
build, and test changes to your project without slowing down</li>
<li><strong>Composable</strong>: split builds and tests into granular steps. Gate CI without
burdening downstream consumers building from source.</li>
</ul>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>Automatic vendoring of dependencies in a way that works with Nix
<ul>
<li>Alternative cargo registries are supported (with a minor configuration
change)</li>
<li>Git dependencies are automatically supported without additional
configuration.
<ul>
<li>Cargo retains the flexibility to only use these dependencies when they are
actually needed, without forcing an override for the entire workspace.</li>
</ul>
</li>
</ul>
</li>
<li>Reusing dependency artifacts after only building them once</li>
<li><a href="https://github.com/rust-lang/rust-clippy">clippy</a> checks</li>
<li><a href="https://github.com/rust-lang/rustfmt">rustfmt</a> checks</li>
<li><a href="https://doc.rust-lang.org/cargo/commands/cargo-doc.html">cargo-doc</a> generation</li>
<li>And support for a number of popular tools such as:
<ul>
<li><a href="https://rustsec.org/">cargo-audit</a></li>
<li><a href="https://github.com/EmbarkStudios/cargo-deny">cargo-deny</a></li>
<li><a href="https://github.com/taiki-e/cargo-llvm-cov">cargo-llvm-cov</a></li>
<li><a href="https://nexte.st/">cargo-nextest</a></li>
<li><a href="https://github.com/xd009642/tarpaulin">cargo-tarpaulin</a></li>
<li><a href="https://trunkrs.dev/">trunk</a></li>
</ul>
</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>The easiest way to get started is to initialize a flake from a template:</p>
<pre><code class="language-sh"># Start with a comprehensive suite of tests
nix flake init -t github:ipetkov/crane#quick-start
</code></pre>
<p>Otherwise check out the <a href="https://crane.dev/getting-started.html">examples and templates</a> for more detailed examples. An
<a href="https://crane.dev/API.html">API Reference</a> is also available.</p>
<h2 id="compatibility-policy"><a class="header" href="#compatibility-policy">Compatibility Policy</a></h2>
<p>Breaking changes can land on the <code>master</code> branch at any time, so it is
recommended you use a versioning strategy when consuming this library (for
example, using something like flakes or <a href="https://github.com/nmattia/niv">niv</a>).</p>
<p>Tagged releases will be cut periodically and changes will be documented in the
<a href="./CHANGELOG.html">CHANGELOG</a>. Release versions will follow <a href="http://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.</p>
<p>The test suite is run against the latest stable nixpkgs release, as well as
<code>nixpkgs-unstable</code>. Any breakage on those channels is considered a bug and
should be reported as such.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This project is licensed under the MIT license.</p>
<h3 id="contribution"><a class="header" href="#contribution">Contribution</a></h3>
<p>Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion by you, shall be licensed as MIT, without any additional terms or
conditions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>All notable changes to this project will be documented in this file.</p>
<p>The format is based on <a href="http://keepachangelog.com/en/1.0.0/">Keep a Changelog</a>
and this project adheres to <a href="http://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.</p>
<h2 id="unreleased"><a class="header" href="#unreleased">Unreleased</a></h2>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<ul>
<li><code>mkDummySrc</code> now accepts <code>dummyBuildrs</code> to customize the dummy source used for
build scripts specifically. If not specified, the value of <code>dummyrs</code> will be
used, otherwise, the existing default dummy build script will be used.</li>
</ul>
<h3 id="fixed"><a class="header" href="#fixed">Fixed</a></h3>
<ul>
<li>Fix Windows pthreads being added to non-Windows platforms when cross compiling</li>
</ul>
<h2 id="0211---2025-09-24"><a class="header" href="#0211---2025-09-24"><a href="https://github.com/ipetkov/crane/compare/v0.21.0...v0.21.1">0.21.1</a> - 2025-09-24</a></h2>
<h3 id="fixed-1"><a class="header" href="#fixed-1">Fixed</a></h3>
<ul>
<li>The default dummy source used by <code>mkDummySrc</code> now additionally works for the
<code>amdgpu</code> target out of the box</li>
<li><code>removeReferencesToRustToolchainHook</code> now handles exclusions case
insensitively</li>
<li><code>cleanCargoToml</code> now retains targets' <code>harness</code> attribute if defined</li>
<li><code>cargoTest</code>, <code>cargoDocTest</code>, and <code>cargoNextest</code> will log a warning if <code>doCheck = false;</code></li>
<li><code>installCargoArtifactsHook</code> gracefully handles (ignores) situations where no
cargo artifacts are generated by the derivation</li>
</ul>
<h2 id="0210---2025-07-19"><a class="header" href="#0210---2025-07-19"><a href="https://github.com/ipetkov/crane/compare/v0.20.3...v0.21.0">0.21.0</a> - 2025-07-19</a></h2>
<h3 id="changed-1"><a class="header" href="#changed-1">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: dropped compatibility for Nix versions below 2.28.3</li>
<li><strong>Breaking</strong>: dropped compatibility for nixpkgs-24.11</li>
<li>Windows cross builds provides pthreads as it is required for most crates.</li>
<li><code>registryFromSparse</code> now passes <code>fetchurlExtraArgs</code> to the initial query for the
registry's <code>config.json</code></li>
</ul>
<h2 id="0203---2025-04-23"><a class="header" href="#0203---2025-04-23"><a href="https://github.com/ipetkov/crane/compare/v0.20.2...v0.20.3">0.20.3</a> - 2025-04-23</a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li><code>mkCrossToolchainEnv</code> is now available for setting up some default
cross-compilation environment variables and derivation arguments</li>
</ul>
<h3 id="changed-2"><a class="header" href="#changed-2">Changed</a></h3>
<ul>
<li>Vendoring git dependencies now respects Cargo.toml <code>includes</code> and <code>excludes</code></li>
<li><code>mkCargoDerivation</code> now configures the cross-compilation toolchain by default
using the newly added <code>mkCrossToolchainEnv</code> function. To select the utilized
cross compiler, the <code>stdenv</code> argument now also accepts a selector function,
taking an arbitrary <code>pkgs</code> instantiation as an argument. This behavior can be
turned off by setting <code>doIncludeCrossToolchainEnv = false;</code>.</li>
</ul>
<h2 id="0202---2025-03-08"><a class="header" href="#0202---2025-03-08"><a href="https://github.com/ipetkov/crane/compare/v0.20.1...v0.20.2">0.20.2</a> - 2025-03-08</a></h2>
<h3 id="changed-3"><a class="header" href="#changed-3">Changed</a></h3>
<ul>
<li><code>craneUtils</code> (used internally for vendoring git dependencies) now uses
<code>importCargoLock</code> to fetch its own dependencies instead of the (now
deprecated) <code>fetchCargoTarball</code> method.</li>
<li><code>cleanCargoToml</code> now preserves the <code>proc-macro</code> attribute of any defined
targets</li>
</ul>
<h3 id="fixed-2"><a class="header" href="#fixed-2">Fixed</a></h3>
<ul>
<li><code>buildTrunkPackage</code> no longer ignores <code>installPhase</code> and <code>installPhaseCommand</code> args.</li>
<li><code>mkDummySrc</code> now supports embedded proc-macros.</li>
<li><code>removeReferencesToRustToolchainHook</code> now handles file names which contain
whitespace</li>
<li><code>removeReferencesToVendoredSourcesHook</code> now handles file names which contain
whitespace</li>
</ul>
<h2 id="0201---2025-02-08"><a class="header" href="#0201---2025-02-08"><a href="https://github.com/ipetkov/crane/compare/v0.20.0...v0.20.1">0.20.1</a> - 2025-02-08</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li><code>cargoNextest</code> now supports passing <code>cargoNextestPartitionsExtraArgs</code> to each
<code>cargo nextest</code> partition run.</li>
<li>Add self-reference <code>craneLib</code> to crane lib instance.</li>
<li>Add <code>removeReferencesToRustToolchainHook</code>, which, by default, removes
references to the Rust toolchain from all installed binaries</li>
</ul>
<h3 id="changed-4"><a class="header" href="#changed-4">Changed</a></h3>
<ul>
<li><code>buildPackage</code> now includes <code>removeReferencesToRustToolchainHook</code> as a native
dependency. To disable automatically removing references to the Rust
toolchain, set <code>doNotRemoveReferencesToRustToolchain = true;</code></li>
<li><code>mkCargoDerivation</code> now will also append the <code>rustc</code> package to the
derivation's <code>nativeBuildInputs</code></li>
</ul>
<h2 id="0200---2024-12-21"><a class="header" href="#0200---2024-12-21"><a href="https://github.com/ipetkov/crane/compare/v0.19.4...v0.20.0">0.20.0</a> - 2024-12-21</a></h2>
<h3 id="changed-5"><a class="header" href="#changed-5">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: dropped compatibility for Nix versions below 2.24.10</li>
<li><strong>Breaking</strong>: dropped compatibility for nixpkgs-24.05</li>
<li><strong>Breaking</strong> (technically): <code>buildPackage</code>'s installation behavior has been
split into two steps: binaries are now installed into a temporary directory as
a post build hook (to avoid interference from the check phase clobbering
resultant binaries with development features enabled) followed by an actual
installation (from said directory) during the install phase. If you use a
custom build phase with <code>buildPackage</code> you may need to ensure the additional
post build hook defined in <code>installFromCargoBuildLogHook</code> runs (or follow the
error messages to resolve any build issues).</li>
<li><code>mkDummySrc</code> has been reworked to match cargo's <code>autobin</code> detection logic,
meaning that only real binary targets defined by the project will be dummified
if they exist (no more injecting <code>src/bin/crane-dummy-*</code>). This does mean that
adding a new bin target definition will invalidate caches and require
rebuilding all dependencies once more. (If this is a frequent enough
occurrence for your project to cause headaches, please open an issue!)</li>
</ul>
<h3 id="fixed-3"><a class="header" href="#fixed-3">Fixed</a></h3>
<ul>
<li><code>mkDummySrc</code> will deduplicate discovered and declared binary targets when
dummifying sources</li>
<li><code>crateNameFromCargoToml</code> will ignore store contexts when parsing a Cargo.toml
file (avoiding errors like <code>the string ... is not allowed to refer to a store path</code>).</li>
<li><code>vendorGitDeps</code> will perform a basic URL-decoding of git dependency entries in
the <code>Cargo.lock</code> file since lockfiles now encode special characters starting
at version 4</li>
</ul>
<h3 id="meta"><a class="header" href="#meta">Meta</a></h3>
<ul>
<li>Dropped support for publishing releases to https://flakestry.dev/</li>
</ul>
<h2 id="0194---2024-11-30"><a class="header" href="#0194---2024-11-30"><a href="https://github.com/ipetkov/crane/compare/v0.19.3...v0.19.4">0.19.4</a> - 2024-11-30</a></h2>
<h3 id="fixed-4"><a class="header" href="#fixed-4">Fixed</a></h3>
<ul>
<li><code>removeReferencesToVendoredSources</code> now deduplicates any found references to
avoid pathological memory usage before removing them.</li>
<li><code>buildDepsOnly</code> will calculate fallback <code>pname</code>/<code>version</code>/<code>cargoVendorDir</code>
attributes using <code>dummySrc</code> if it was specified (rather than attempting to use
<code>src</code>)</li>
</ul>
<h2 id="0193---2024-11-18"><a class="header" href="#0193---2024-11-18"><a href="https://github.com/ipetkov/crane/compare/v0.19.2...v0.19.3">0.19.3</a> - 2024-11-18</a></h2>
<p>A republish of 0.19.2 which was incorrectly tagged.</p>
<h2 id="0192---2024-11-18"><a class="header" href="#0192---2024-11-18"><a href="https://github.com/ipetkov/crane/compare/v0.19.1...v0.19.2">0.19.2</a> - 2024-11-18</a></h2>
<h3 id="added-2"><a class="header" href="#added-2">Added</a></h3>
<ul>
<li>Added a number of fileset helpers to more easily compose source filtering:
<ul>
<li><code>fileset.cargoTomlAndLock</code>: for <code>Cargo.toml</code> and <code>Cargo.lock</code> files</li>
<li><code>fileset.commonCargoSources</code>: for files commonly used by cargo projects</li>
<li><code>fileset.configToml</code>: for <code>config.toml</code> files</li>
<li><code>fileset.rust</code>: for <code>*.rs</code> files</li>
<li><code>fileset.toml</code>: for <code>*.toml</code> files</li>
</ul>
</li>
</ul>
<h3 id="fixed-5"><a class="header" href="#fixed-5">Fixed</a></h3>
<ul>
<li><code>buildTrunkPackage</code> will pass in <code>--release=true</code> (instead of just
<code>--release</code>) for trunk versions 0.21 or higher to avoid argument ambiguities</li>
<li><code>buildTrunkPackage</code> will now correctly honor <code>buildPhaseCargoCommand</code> if
specified (previously the value of <code>buildPhaseCommand</code> was incorrectly being
used)</li>
<li><code>removeReferencesToVendoredSourcesHook</code> avoids referencing <code>/dev/fd</code>
directly since it may not be present on certain platforms</li>
</ul>
<h2 id="0191---2024-10-12"><a class="header" href="#0191---2024-10-12"><a href="https://github.com/ipetkov/crane/compare/v0.19.0...v0.19.1">0.19.1</a> - 2024-10-12</a></h2>
<h3 id="added-3"><a class="header" href="#added-3">Added</a></h3>
<ul>
<li><code>cargoDocTest</code> is now available as an alternative to <code>cargoTest</code> which runs
only doc tests.</li>
</ul>
<h3 id="changed-6"><a class="header" href="#changed-6">Changed</a></h3>
<ul>
<li><code>buildDepsOnly</code> now sets <code>CRANE_BUILD_DEPS_ONLY</code> as an environment variable
when it runs. Build hooks can use this as a shortcut to determine whether
running inside of a <code>buildDepsOnly</code> derivation in case they need to tailor
their behavior accordingly.</li>
</ul>
<h3 id="fixed-6"><a class="header" href="#fixed-6">Fixed</a></h3>
<ul>
<li>Vendoring dependencies avoids creating malformed TOML configurations in
situations where registry name/url definitions cannot be found. When this
happens a warning will be printed out during evaluation to highlight the
issue.</li>
</ul>
<h2 id="0190---2024-09-25"><a class="header" href="#0190---2024-09-25"><a href="https://github.com/ipetkov/crane/compare/v0.18.1...v0.19.0">0.19.0</a> - 2024-09-25</a></h2>
<h3 id="added-4"><a class="header" href="#added-4">Added</a></h3>
<ul>
<li><code>taploFmt</code> is now available for checking TOML formatting</li>
</ul>
<h3 id="changed-7"><a class="header" href="#changed-7">Changed</a></h3>
<ul>
<li><strong>Breaking</strong> (technically): <code>buildPackage</code> no longer adds <code>jq</code> to
<code>nativeBuildInputs</code> as doing so can result in rebuilding any <code>*-sys</code> crates
which rely on <code>PKG_CONFIG_PATH</code> remaining stable</li>
<li><strong>Breaking</strong>: <code>downloadCargoPackageFromGit</code> now takes <code>hash</code> instead of
<code>sha256</code> when specifying an output hash for the download</li>
<li><code>installFromCargoBuildLogHook</code> no longer assumes or requires that <code>jq</code> is
available on <code>$PATH</code> and will instead directly reference <code>pkgs.jq</code></li>
<li><code>downloadCargoPackageFromGit</code> will now set <code>fetchLFS = true</code> when fetching git
repos with defined output hashes</li>
</ul>
<h3 id="fixed-7"><a class="header" href="#fixed-7">Fixed</a></h3>
<ul>
<li><code>cargoDoc</code> correctly honors <code>docInstallRoot</code> when specified</li>
<li><code>cargoDoc</code> falls back to installing from <code>./target/doc</code> even if
<code>$CARGO_BUILD_TARGET</code> is set but <code>./target/$CARGO_BUILD_TARGET/doc</code> does not
exist</li>
</ul>
<h3 id="removed"><a class="header" href="#removed">Removed</a></h3>
<ul>
<li>The deprecated top-level (flake) attribute <code>lib</code> no longer exists. Please use
<code>mkLib</code> with an instance of <code>pkgs</code> instead.</li>
</ul>
<h2 id="0181---2024-08-22"><a class="header" href="#0181---2024-08-22"><a href="https://github.com/ipetkov/crane/compare/v0.18.0...v0.18.1">0.18.1</a> - 2024-08-22</a></h2>
<h3 id="fixed-8"><a class="header" href="#fixed-8">Fixed</a></h3>
<ul>
<li>Fixed vendoring dependencies from an alternative registry which they
themselves have dependencies on crates from <em>other</em> registries.</li>
<li>Fixed <code>cargoNextest</code>'s positioning of <code>cargoExtraArgs</code> to form a valid command
invocation when specified.</li>
</ul>
<h2 id="0180---2024-07-05"><a class="header" href="#0180---2024-07-05"><a href="https://github.com/ipetkov/crane/compare/v0.17.3...v0.18.0">0.18.0</a> - 2024-07-05</a></h2>
<h3 id="changed-8"><a class="header" href="#changed-8">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: dropped compatibility for Nix versions below 2.18.2</li>
<li><strong>Breaking</strong>: dropped compatibility for nixpkgs-23.11</li>
<li>The guidance around using (both) <code>cleanCargoSource</code> and <code>path</code> has been
updated. Namely, it is no longer necessary to call both (e.g.
<code>craneLib.cleanCargoSource (craneLib.path ./.)</code>): it is recommended to either
use <code>craneLib.cleanCargoSource ./.</code> directly (if the default source cleaning
is desired) or <code>craneLib.path ./.</code> (if not).</li>
<li><code>overrideToolchain</code> has been updated to better handle cross-compilation
splicing for a customized toolchain. This means that <code>overrideToolchain</code>
should now be called with a function which constructs said toolchain for any
given <code>pkgs</code> instantiation. For example: <code>craneLib.overrideToolchain (p: p.rust-bin.stable.latest.default)</code></li>
</ul>
<h3 id="fixed-9"><a class="header" href="#fixed-9">Fixed</a></h3>
<ul>
<li>The cross compilation example also hows how to set the <code>TARGET_CC</code> environment
variable which may be required by some build scripts to function properly</li>
<li><code>vendorCargoDeps</code> and <code>crateNameFromCargoToml</code> do their best to avoid IFD when
<code>src</code> is the result of <code>lib.cleanSourceWith</code> (and by extension
<code>cleanCargoSource</code>)</li>
<li><code>removeReferencesToVendoredSources</code> handles the edge case where
<code>cargoVendorDir</code> does not point to a path within the Nix store</li>
<li>It is now possible to use <code>.overrideScope</code> to change what instance of
<code>craneUtils</code> will be used during vendoring.</li>
</ul>
<h2 id="0173---2024-06-02"><a class="header" href="#0173---2024-06-02"><a href="https://github.com/ipetkov/crane/compare/v0.17.2...v0.17.3">0.17.3</a> - 2024-06-02</a></h2>
<h3 id="fixed-10"><a class="header" href="#fixed-10">Fixed</a></h3>
<ul>
<li><code>removeReferencesToVendoredSources</code> correctly signs aarch64-darwin builds
(which was accidentally broken in 0.17.2)</li>
</ul>
<h2 id="0172---2024-05-26"><a class="header" href="#0172---2024-05-26"><a href="https://github.com/ipetkov/crane/compare/v0.17.1...v0.17.2">0.17.2</a> - 2024-05-26</a></h2>
<h3 id="fixed-11"><a class="header" href="#fixed-11">Fixed</a></h3>
<ul>
<li><code>removeReferencesToVendoredSources</code> has been optimized to search for source
references only once. For derivations which install many files, this phase can
run up to 99% faster than before.</li>
<li><code>cleanCargoToml</code> now cleans underscored versions of the same attributes (e.g.
<code>lib.proc-macro</code> and <code>lib.proc_macro</code>)</li>
</ul>
<h2 id="0171---2024-05-19"><a class="header" href="#0171---2024-05-19"><a href="https://github.com/ipetkov/crane/compare/v0.17.0...v0.17.1">0.17.1</a> - 2024-05-19</a></h2>
<h3 id="fixed-12"><a class="header" href="#fixed-12">Fixed</a></h3>
<ul>
<li><code>downloadCargoPackage</code> and <code>downloadCargoPackageFromGit</code> no longer run the
fixup phase by default, avoiding issues with source directories and files
being moved to different locations</li>
<li><code>downloadCargoPackage</code> now unpacks and installs from a fresh directory,
avoiding having build environment files (like <code>env-vars</code>) appearing in the
output</li>
</ul>
<h2 id="0170---2024-05-18"><a class="header" href="#0170---2024-05-18"><a href="https://github.com/ipetkov/crane/compare/v0.16.6...v0.17.0">0.17.0</a> - 2024-05-18</a></h2>
<h3 id="added-5"><a class="header" href="#added-5">Added</a></h3>
<ul>
<li><code>cargoDoc</code> now supports <code>docInstallRoot</code> to influence which directory will be
installed to <code>$out/share</code> (which can be useful when cross-compiling). By
default <code>$CARGO_TARGET_DIR</code> and <code>$CARGO_BUILD_TARGET</code> (if set) will be taken
into account</li>
<li><code>crateNameFromCargoToml</code> now supports selecting a derivation name by setting
<code>package.metadata.crane.name</code> or <code>workspace.metadata.crane.name</code> in the root
<code>Cargo.toml</code></li>
<li><code>vendorCargoDeps</code>, <code>vendorCargoRegistries</code>, <code>vendorGitDeps</code>, and
<code>vendorMultipleCargoDeps</code> now support arbitrary overrides (i.e. patching) at
the individual crate/repo level when vendoring sources.</li>
</ul>
<h3 id="changed-9"><a class="header" href="#changed-9">Changed</a></h3>
<ul>
<li><strong>Breaking</strong> <code>cargoAudit</code> no longer accepts <code>cargoExtraArgs</code> (since it does
not support the regular set of <code>cargo</code> flags like most cargo-commands do, it
does not make much sense to propagate those flags through)</li>
<li><code>buildTrunkPackage</code> now sets <code>env.TRUNK_SKIP_VERSION_CHECK = "true";</code> if not
specified</li>
</ul>
<h3 id="deprecations"><a class="header" href="#deprecations">Deprecations</a></h3>
<ul>
<li>In the future, <code>crateNameFromCargoToml</code> will stop considering
<code>workspace.package.name</code> in the root <code>Cargo.toml</code> when determining the crate
name. This attribute is not recognized by cargo (which will emit its own
warnings about it) and should be avoided going forward.</li>
<li>In the future, <code>crane.lib.${system}</code> will be removed. Please switch to using
<code>(crane.mkLib nixpkgs.lib.${system})</code> as an equivalent alternative.</li>
</ul>
<h2 id="0166---2024-05-04"><a class="header" href="#0166---2024-05-04"><a href="https://github.com/ipetkov/crane/compare/v0.16.5...v0.16.6">0.16.6</a> - 2024-05-04</a></h2>
<h3 id="fixed-13"><a class="header" href="#fixed-13">Fixed</a></h3>
<ul>
<li>Same as 0.16.5 but with the correct tag deployed to Flakestry/FlakeHub</li>
</ul>
<h2 id="0165---2024-05-04"><a class="header" href="#0165---2024-05-04"><a href="https://github.com/ipetkov/crane/compare/v0.16.4...v0.16.5">0.16.5</a> - 2024-05-04</a></h2>
<h3 id="fixed-14"><a class="header" href="#fixed-14">Fixed</a></h3>
<ul>
<li>Workspace inheritance for git dependencies now ignores (removes) all comments
around dependency declarations to work around a mangling bug in <code>toml_edit</code>
(see https://github.com/ipetkov/crane/issues/527 and
https://github.com/toml-rs/toml/issues/691)</li>
</ul>
<h2 id="0164---2024-04-07"><a class="header" href="#0164---2024-04-07"><a href="https://github.com/ipetkov/crane/compare/v0.16.3...v0.16.4">0.16.4</a> - 2024-04-07</a></h2>
<h3 id="added-6"><a class="header" href="#added-6">Added</a></h3>
<ul>
<li>Added a warning if an unsupported version of nixpkgs is used</li>
</ul>
<h3 id="changed-10"><a class="header" href="#changed-10">Changed</a></h3>
<ul>
<li><code>cargoNextest</code> now supports setting <code>withLlvmCov</code> which will automatically run
<code>cargo llvm-cov nextest</code>. Note that <code>withLlvmCov = true;</code> is (currently) only
supported when <code>partitions = 1;</code></li>
</ul>
<h3 id="fixed-15"><a class="header" href="#fixed-15">Fixed</a></h3>
<ul>
<li><code>inheritCargoArtifactsHook</code> and <code>installCargoArtifactsHook</code> now correctly
handle the case when <code>CARGO_TARGET_DIR</code> is set to a nested directory</li>
<li>Dependency vendoring now correctly takes unused patch dependencies into
account</li>
</ul>
<h2 id="0163---2024-03-19"><a class="header" href="#0163---2024-03-19"><a href="https://github.com/ipetkov/crane/compare/v0.16.2...v0.16.3">0.16.3</a> - 2024-03-19</a></h2>
<h3 id="changed-11"><a class="header" href="#changed-11">Changed</a></h3>
<ul>
<li>Sources are now fetched <a href="https://blog.rust-lang.org/2024/03/11/crates-io-download-changes.html">crates.io's
CDN</a>,
following cargo's (new) default behavior.</li>
</ul>
<h3 id="fixed-16"><a class="header" href="#fixed-16">Fixed</a></h3>
<ul>
<li><code>vendorMultipleCargoDeps</code> correctly lists <code>registries</code> as an optional
parameter</li>
</ul>
<h2 id="0162---2024-02-21"><a class="header" href="#0162---2024-02-21"><a href="https://github.com/ipetkov/crane/compare/v0.16.1...v0.16.2">0.16.2</a> - 2024-02-21</a></h2>
<h3 id="changed-12"><a class="header" href="#changed-12">Changed</a></h3>
<ul>
<li><code>cleanCargoToml</code> now also strips out <code>[lints]</code> and <code>[workspace.lints]</code>
definitions. This means avoiding unnecessarily rebuilding dependencies when
the lint definitions change, and it avoids issues with failing to build
dummified sources which might have violated a lint marked as <code>deny</code> or
<code>forbid</code></li>
</ul>
<h3 id="fixed-17"><a class="header" href="#fixed-17">Fixed</a></h3>
<ul>
<li>Fixed an edge case with inheriting workspace dependencies where the workspace
dependency is a string (e.g. <code>foo = "0.1.2"</code>) but the crate definition is a
table (e.g. <code>foo = { workspace = true, optional = true }</code>)</li>
</ul>
<h2 id="0161---2024-01-28"><a class="header" href="#0161---2024-01-28"><a href="https://github.com/ipetkov/crane/compare/v0.16.0...v0.16.1">0.16.1</a> - 2024-01-28</a></h2>
<h3 id="changed-13"><a class="header" href="#changed-13">Changed</a></h3>
<ul>
<li><code>buildDepsOnly</code> now ignores any outputs (besides the default <code>out</code>)</li>
</ul>
<h3 id="fixed-18"><a class="header" href="#fixed-18">Fixed</a></h3>
<ul>
<li><code>buildDepsOnly</code> no longer fails when workspace is configured with
<code>#[deny(unused-extern-crates)]</code></li>
<li><code>vendorCargoDeps</code> (and friends) are now much more friendly to
cross-compilation definitions. Specifically, source vendoring will always
build dependencies to run on the build machine (and not for the host we're
cross compiling to).</li>
</ul>
<h2 id="0160---2024-01-18"><a class="header" href="#0160---2024-01-18"><a href="https://github.com/ipetkov/crane/compare/v0.15.1...v0.16.0">0.16.0</a> - 2024-01-18</a></h2>
<h3 id="changed-14"><a class="header" href="#changed-14">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: dropped compatibility for Nix versions below 2.18.1</li>
<li><strong>Breaking</strong>: dropped compatibility for nixpkgs-23.05.</li>
<li><code>buildTrunkPackage</code> has a new argument, <code>wasm-bindgen-cli</code> must be set
to avoid mismatching versions between the wasm-bindgen library and CLI tool.</li>
</ul>
<h3 id="fixed-19"><a class="header" href="#fixed-19">Fixed</a></h3>
<ul>
<li>Workspace inheritance of <code>lints</code> in git dependencies is now correctly handled</li>
</ul>
<h2 id="0151---2023-11-30"><a class="header" href="#0151---2023-11-30"><a href="https://github.com/ipetkov/crane/compare/v0.15.0...v0.15.1">0.15.1</a> - 2023-11-30</a></h2>
<h3 id="changed-15"><a class="header" href="#changed-15">Changed</a></h3>
<ul>
<li><code>buildDepsOnly</code> will now assume <code>cargoTestExtraArgs = "--no-run";</code> if not
specified (since there is no point to trying to run tests with the stripped
sources). To get the old behavior back, set <code>cargoTestExtraArgs = "";</code></li>
</ul>
<h3 id="fixed-20"><a class="header" href="#fixed-20">Fixed</a></h3>
<ul>
<li><code>buildTrunkPackage</code>'s <code>preConfigure</code> script to fail quicker with a more
obvious error message if dependencies at not appropriately met</li>
</ul>
<h2 id="0150---2023-11-05"><a class="header" href="#0150---2023-11-05"><a href="https://github.com/ipetkov/crane/compare/v0.14.3...v0.15.0">0.15.0</a> - 2023-11-05</a></h2>
<h3 id="added-7"><a class="header" href="#added-7">Added</a></h3>
<ul>
<li><code>cargoDeny</code> added for running <a href="https://github.com/EmbarkStudios/cargo-deny"><code>cargo-deny</code></a>.</li>
<li><code>installCargoArtifactsHook</code> will now pass along the contents of
<code>$zstdCompressionExtraArgs</code> as arguments to <code>zstd</code> when compressing artifacts.
This allows for tailoring compression behavior, for example, by setting
<code>zstdCompressionExtraArgs = "-19";</code> on the derivation.</li>
</ul>
<h3 id="changed-16"><a class="header" href="#changed-16">Changed</a></h3>
<ul>
<li>The <code>use-zstd</code> artifact installation mode now uses a chained, incremental
approach to avoid redundancy. Old behavior (taking a full snapshot of the
cargo artifacts) can be achieved by setting <code>doCompressAndInstallFullArchive = true</code>.</li>
<li>The default <code>installCargoArtifactsMode</code> has been changed to <code>use-zstd</code>,
meaning cargo artifacts will be compressed to a series of incremental, zstd
compressed tarballs across derivations. To get the old behavior back, set
<code>installCargoArtifactsMode = "use-symlink"</code> to any derivation which produces
cargo artifacts.</li>
<li>All dependencies (outside of <code>nixpkgs</code>) have been dropped from the (main)
flake.lock file so they do not pollute downstream projects' lock files.</li>
</ul>
<h3 id="fixed-21"><a class="header" href="#fixed-21">Fixed</a></h3>
<ul>
<li><code>mkDummySrc</code> now properly handles file cleaning (and file including) when a
build is invoked with a <code>--store ...</code> override</li>
</ul>
<h2 id="0143---2023-10-17"><a class="header" href="#0143---2023-10-17"><a href="https://github.com/ipetkov/crane/compare/v0.14.2...v0.14.3">0.14.3</a> - 2023-10-17</a></h2>
<h3 id="changed-17"><a class="header" href="#changed-17">Changed</a></h3>
<ul>
<li><code>craneUtils</code> will now be built with the <code>rustPlatform</code> provided by nixpkgs
instead of the currently configured toolchain. This should hopefully result in
fewer surprises for those testing with really old MSRV toolchains.</li>
<li><code>devShell</code> will now additionally include <code>clippy</code> and <code>rustfmt</code> from the
currently configured toolchain</li>
</ul>
<h3 id="fixed-22"><a class="header" href="#fixed-22">Fixed</a></h3>
<ul>
<li><code>replaceCargoLockHook</code> now runs as a <code>prePatch</code> hook (rather
than <code>postUnpack</code>) which correctly replaces the <code>Cargo.lock</code> in the source
directory rather than the parent directory</li>
</ul>
<h2 id="0142---2023-10-15"><a class="header" href="#0142---2023-10-15"><a href="https://github.com/ipetkov/crane/compare/v0.14.1...v0.14.2">0.14.2</a> - 2023-10-15</a></h2>
<h3 id="added-8"><a class="header" href="#added-8">Added</a></h3>
<ul>
<li><code>replaceCargoLockHook</code> can now be used to easily replace or insert a
<code>Cargo.lock</code> file in the current derivation</li>
</ul>
<h3 id="changed-18"><a class="header" href="#changed-18">Changed</a></h3>
<ul>
<li><code>cargoAudit</code> will pass <code>--ignore yanked</code> by default if <code>cargoAuditExtraArgs</code>
are not specified. This is because <code>cargo-audit</code> cannot check for yanked
crates from inside of the sandbox. To get the old behavior back, set
<code>cargoAuditExtraArgs = "";</code>.</li>
</ul>
<h3 id="fixed-23"><a class="header" href="#fixed-23">Fixed</a></h3>
<ul>
<li>Fixed handling of Cargo workspace inheritance for git-dependencies where said
crate relies on reading non-TOML metadata (i.e. comments) from its Cargo.toml
at build time. (<a href="https://github.com/ipetkov/crane/pull/407">#407</a>)</li>
<li>Fixed handling of dummy target names to avoid issues with <code>cargo doc</code>.
(<a href="https://github.com/ipetkov/crane/pull/410">#410</a>)</li>
<li>When using <code>installCargoArtifactsMode = "use-zstd";</code> all files will be marked
as user-writable while compressing</li>
<li><code>removeReferencesToVendoredSources</code> now signs <code>aarch64-darwin</code> binaries. (<a href="https://github.com/ipetkov/crane/pull/418">#418</a>)</li>
</ul>
<h2 id="0141---2023-09-23"><a class="header" href="#0141---2023-09-23"><a href="https://github.com/ipetkov/crane/compare/v0.14.0...v0.14.1">0.14.1</a> - 2023-09-23</a></h2>
<h3 id="fixed-24"><a class="header" href="#fixed-24">Fixed</a></h3>
<ul>
<li>Fixed a bug where <code>buildPackage</code> would fail to inherit artifacts from
dependency crates if <code>cargoArtifacts</code> was not explicitly specified.</li>
</ul>
<h2 id="0140---2023-09-21"><a class="header" href="#0140---2023-09-21"><a href="https://github.com/ipetkov/crane/compare/v0.13.1...v0.14.0">0.14.0</a> - 2023-09-21</a></h2>
<h3 id="added-9"><a class="header" href="#added-9">Added</a></h3>
<ul>
<li>Added <code>devShell</code>, a thin wrapper around <code>pkgs.mkShell</code> which automatically
provides <code>cargo</code> and <code>rustc</code>.</li>
<li>Added the ability to specify output hashes of git dependencies for fully
offline evaluations. The <code>outputHashes</code> attribute can now be optionally
specified in <code>vendorCargoDeps</code>, <code>vendorGitDeps</code>, <code>vendorMultipleCargoDeps</code>, or
anything else which delegates to them.</li>
</ul>
<h3 id="changed-19"><a class="header" href="#changed-19">Changed</a></h3>
<ul>
<li><strong>Breaking</strong> (technically): <code>buildDepsOnly</code>, <code>buildPackage</code>, <code>cargoBuild</code>,
<code>cargoClippy</code>, <code>cargoDoc</code>, <code>cargoLlvmCov</code>, and <code>cargoTest</code>'s defaults have
been changed such that if <code>cargoExtraArgs</code> have not been set, a default value
of <code>--locked</code> will be used. This ensures that a project's committed
<code>Cargo.lock</code> is exactly what is expected (without implicit changes at build
time) but this may end up rejecting builds which were previously passing. To
get the old behavior back, set <code>cargoExtraArgs = "";</code></li>
<li><strong>Breaking</strong>: <code>cargoDoc</code> will no longer install cargo artifacts by default.
Set <code>doInstallCargoArtifacts = true;</code> to get the old behavior back.</li>
<li><code>cargoDoc</code> will now install generated documentation in <code>$out/share/doc</code></li>
<li>Fixed a bug when testing proc macro crates with <code>cargoNextest</code> on macOS.
(<a href="https://github.com/ipetkov/crane/pull/376">#376</a>)</li>
<li>Replaced various internal usages of <code>runCommandLocal</code> with <code>runCommand</code> for
more optimal behavior when downloading cached artifacts</li>
</ul>
<h2 id="0131---2023-08-22"><a class="header" href="#0131---2023-08-22"><a href="https://github.com/ipetkov/crane/compare/v0.13.0...v0.13.1">0.13.1</a> - 2023-08-22</a></h2>
<h3 id="changed-20"><a class="header" href="#changed-20">Changed</a></h3>
<ul>
<li><code>buildTrunkPackage</code> will now use <code>dart-sass</code> instead of <code>nodePackages.sass</code></li>
<li>Vendoring git dependencies will now always resolve symlinks inside of a
crate's directory. This allows for symlinks inside of a crate's directory to
possibly refer to files at the root of the git repo itself (via symlink) and
have those contents preserved during vendoring.</li>
</ul>
<h2 id="0130---2023-08-07"><a class="header" href="#0130---2023-08-07"><a href="https://github.com/ipetkov/crane/compare/v0.12.2...v0.13.0">0.13.0</a> - 2023-08-07</a></h2>
<h3 id="added-10"><a class="header" href="#added-10">Added</a></h3>
<ul>
<li><code>buildPackage</code> now supports installing <code>dylib</code> targets</li>
<li>Added support for sparse registries</li>
</ul>
<h3 id="changed-21"><a class="header" href="#changed-21">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: dropped compatibility for Nix versions below 2.13.3</li>
<li><strong>Breaking</strong>: dropped compatibility for nixpkgs-22.05. nixpkgs-23.05 and</li>
<li><strong>Breaking</strong> (technically): if <code>buildPackage</code> is called <em>without</em> setting
<code>cargoArtifacts</code>, the default <code>buildDepsOnly</code> invocation will now stop running
any installation hooks</li>
<li><strong>Breaking</strong> (technically): <code>buildPackage</code> no longer installs cargo binary
dependencies (i.e. when the <code>bindeps</code> feature is used) by default</li>
<li><code>inheritCargoArtifactsHook</code> will now symlink dependency <code>.rlib</code> and <code>.rmeta</code>
files. This means that derivations which reuse existing cargo artifacts will
run faster as fewer files (and bytes!) need to be copied around. To disable
this behavior, set <code>doNotLinkInheritedArtifacts = true;</code>.</li>
<li><code>cargoTarpaulin</code> will now set <code>doNotLinkInheritedArtifacts = true;</code> unless
otherwise specified</li>
<li>Update <code>crane-utils</code> dependencies for successful build in nightly Rust (2023-06-28)</li>
</ul>
<h2 id="0122---2023-06-06"><a class="header" href="#0122---2023-06-06"><a href="https://github.com/ipetkov/crane/compare/v0.12.1...v0.12.2">0.12.2</a> - 2023-06-06</a></h2>
<h3 id="added-11"><a class="header" href="#added-11">Added</a></h3>
<ul>
<li>Added support for the <a href="https://trunkrs.dev">Trunk</a> wasm app build tool</li>
</ul>
<h3 id="changed-22"><a class="header" href="#changed-22">Changed</a></h3>
<ul>
<li><code>resolver</code> key is no longer cleaned from Cargo.toml</li>
</ul>
<h3 id="fixed-25"><a class="header" href="#fixed-25">Fixed</a></h3>
<ul>
<li><code>buildTrunkPackage</code> will now strip references to store files by default</li>
<li><code>buildTrunkPackage</code> will now set the right <code>wasm-opt</code> version</li>
</ul>
<h2 id="0121---2023-04-10"><a class="header" href="#0121---2023-04-10"><a href="https://github.com/ipetkov/crane/compare/v0.12.0...v0.12.1">0.12.1</a> - 2023-04-10</a></h2>
<h3 id="changed-23"><a class="header" href="#changed-23">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: When setting a default value for <code>cargoArtifacts</code>,
<code>buildPackage</code> will now ignore <code>installPhase</code> and <code>installPhaseCommand</code> when
calling <code>buildPackage</code>. To bring back the old behavior, please specify
<code>cargoArtifacts</code> explicitly</li>
</ul>
<h3 id="added-12"><a class="header" href="#added-12">Added</a></h3>
<ul>
<li><code>vendorMultipleCargoDeps</code> can now be used to vendor crates from multiple
distinct <code>Cargo.lock</code> files. Notably this allows for building the standard
library (via <code>-Z build-std</code> or equivalent) since both the project's
and the Rust toolchain's <code>Cargo.lock</code> files can be vendored together</li>
</ul>
<h3 id="changed-24"><a class="header" href="#changed-24">Changed</a></h3>
<ul>
<li><code>vendorCargoRegistries</code> now accepts a <code>registries</code> parameter from the caller.
If not specified, it will be computed via <code>cargoConfigs</code>. Also <code>cargoConfigs</code>
is now an optional parameter which will default to <code>[]</code> if not specified.</li>
</ul>
<h3 id="fixed-26"><a class="header" href="#fixed-26">Fixed</a></h3>
<ul>
<li><code>vendorCargoDeps</code> correctly accepts arguments which have <em>not</em> set <code>src</code>, so
long as one of <code>cargoLock</code>, <code>cargoLockContents</code>, or <code>cargoLockParsed</code> is set</li>
</ul>
<h2 id="0120---2023-03-19"><a class="header" href="#0120---2023-03-19"><a href="https://github.com/ipetkov/crane/compare/v0.11.3...v0.12.0">0.12.0</a> - 2023-03-19</a></h2>
<h3 id="added-13"><a class="header" href="#added-13">Added</a></h3>
<ul>
<li>Add a stubbed binary target to each "dummy" crate generated to support
<a href="https://doc.rust-lang.org/cargo/reference/unstable.html#artifact-dependencies">"artifact dependencies" nightly feature</a>
in case a crate is used as <code>bin</code> artifact dependency.</li>
<li>Add <code>cargoLlvmCov</code> to run <code>cargo llvm-cov</code></li>
<li>Add <code>cargoLockParsed</code> option to <code>vendorCargoDeps</code> to support <code>Cargo.lock</code>
files parsed as nix attribute sets.</li>
<li><code>craneLib.path</code> can now be used as a convenience wrapper on (or drop in
replacement of) <code>builtins.path</code> to ensure reproducible results whenever paths
like <code>./.</code> or <code>./..</code> are used directly.</li>
</ul>
<h3 id="changed-25"><a class="header" href="#changed-25">Changed</a></h3>
<ul>
<li><strong>Breaking</strong> (technically): <code>mkCargoDerivation</code> will remove the following
attributes before lowering to <code>mkDerivation</code>: <code>cargoLock</code>, <code>cargoLockContents</code>
and <code>cargoLockParsed</code>. If your derivation needs these values to be present
they can be explicitly passed through via <code>.overrideAttrs</code>
<code>buildDepsOnly</code> as <code>dummySrc</code> will take priority</li>
<li>The API docs have been updated to refer to <code>craneLib</code> (instead of just <code>lib</code>)
to avoid ambiguities with <code>pkgs.lib</code>.</li>
<li>cargo is now invoked with <code>--release</code> when <code>$CARGO_PROFILE == release</code> instead
of passing in <code>--profile release</code> to better support tools which do not
understand the latter</li>
</ul>
<h3 id="fixed-27"><a class="header" href="#fixed-27">Fixed</a></h3>
<ul>
<li>Fixed support for projects depending on crates utilising per-target workspace dependencies.</li>
</ul>
<h2 id="0113---2023-02-19"><a class="header" href="#0113---2023-02-19"><a href="https://github.com/ipetkov/crane/compare/v0.11.2...v0.11.3">0.11.3</a> - 2023-02-19</a></h2>
<h3 id="fixed-28"><a class="header" href="#fixed-28">Fixed</a></h3>
<ul>
<li>Fixed an unintentional cache invalidation whenever <code>buildDepsOnly</code> would run
on an unfiltered source (like <code>src = ./.;</code>).</li>
</ul>
<h3 id="changed-26"><a class="header" href="#changed-26">Changed</a></h3>
<ul>
<li>A warning will now be emitted if a derivation's <code>pname</code> or <code>version</code>
attributes are not set and the value cannot be loaded from the derivation's
root <code>Cargo.toml</code>. To resolve it consider setting <code>pname = "...";</code> or <code>version = "...";</code> explicitly on the derivation.</li>
<li>A warning will now be emitted if <code>src</code> and <code>dummySrc</code> are passed to
<code>buildDepsOnly</code> as <code>dummySrc</code> will take priority</li>
</ul>
<h2 id="0112---2023-02-11"><a class="header" href="#0112---2023-02-11"><a href="https://github.com/ipetkov/crane/compare/v0.11.1...v0.11.2">0.11.2</a> - 2023-02-11</a></h2>
<h3 id="fixed-29"><a class="header" href="#fixed-29">Fixed</a></h3>
<ul>
<li><code>buildPackage</code> is more tolerant of misbehaving proc macros which write to
stdout during the build</li>
</ul>
<h2 id="0111---2023-01-21"><a class="header" href="#0111---2023-01-21"><a href="https://github.com/ipetkov/crane/compare/v0.11.0...v0.11.1">0.11.1</a> - 2023-01-21</a></h2>
<h3 id="changed-27"><a class="header" href="#changed-27">Changed</a></h3>
<ul>
<li>Documented and made it easier to build a cargo workspace located in a
subdirectory of the source root</li>
</ul>
<h3 id="fixed-30"><a class="header" href="#fixed-30">Fixed</a></h3>
<ul>
<li>Previously compiled build scripts now maintain their executable bit when
inherited</li>
<li>Workspace inheritance in git dependencies is now correctly handled</li>
</ul>
<h2 id="0110---2022-12-26"><a class="header" href="#0110---2022-12-26"><a href="https://github.com/ipetkov/crane/compare/v0.10.0...v0.11.0">0.11.0</a> - 2022-12-26</a></h2>
<h3 id="added-14"><a class="header" href="#added-14">Added</a></h3>
<ul>
<li>Documentation is now available at <a href="https://crane.dev">crane.dev</a></li>
</ul>
<h3 id="changed-28"><a class="header" href="#changed-28">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: dropped compatibility for Nix versions below 2.11.0</li>
<li><strong>Breaking</strong>: dropped compatibility for nixpkgs-22.05. nixpkgs-22.11 and
nixpkgs-unstable are fully supported</li>
<li>Zstd compression of cargo artifacts now defaults to using as many cores as
<code>$NIX_BUILD_CORES</code> allows for (or all available cores if it isn't defined)</li>
<li>Dummy sources now attempt to use the same name as their original source (minus
the Nix store path and hash) to minimize errors with build scripts which
expect their full path to not change between runs</li>
</ul>
<h2 id="0100---2022-12-01"><a class="header" href="#0100---2022-12-01"><a href="https://github.com/ipetkov/crane/compare/v0.9.0...v0.10.0">0.10.0</a> - 2022-12-01</a></h2>
<h3 id="added-15"><a class="header" href="#added-15">Added</a></h3>
<ul>
<li>A new installation mode has been defined which symlinks identical cargo
artifacts against previously generated ones. This allows for linear space
usage in the Nix store across many chained derivations (as opposed to using a
zstd compressed tarball which uses quadratic space across many chained
derivations).</li>
<li><code>mkDummySrc</code> optionally accepts a <code>dummyrs</code> argument which allows for
customizing the contents of the dummy Rust files that will be generated.</li>
</ul>
<h3 id="changed-29"><a class="header" href="#changed-29">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: all cargo-based derivations will now default to using symlinking
their installed artifacts together instead of using zstd compressed tarballs.
To get the old behavior back, set <code>installCargoArtifactsMode = "use-zstd";</code> in
the derivation.
<ul>
<li>Note that <code>buildPackage</code> will continue to use zstd compressed tarballs while
building dependencies (unless either of <code>cargoArtifacts</code> or
<code>installCargoArtifactsMode</code> is defined, in which case they will be honored)</li>
</ul>
</li>
<li><strong>Breaking</strong>: the format for defining crate registries has been changed: each
registry URL should map to a set containing a <code>downloadUrl</code> attribute. This
set may also define <code>fetchurlExtraArgs</code> (another set) which will be forwarded
to the <code>fetchurl</code> invocations for crates for that registry.</li>
<li><strong>Breaking</strong> (technically): <code>buildDepsOnly</code> will now only default to running
<code>cargo check</code> with the <code>--all-targets</code> flag only if <code>doCheck = true;</code> is set on
the derivation (otherwise the flag is omitted). To get the previous behavior
back simply set <code>cargoCheckExtraArgs = "--all-targets";</code>.</li>
<li><code>registryFromGitIndex</code> now uses shallow checkouts for better performance</li>
<li><code>registryFromDownloadUrl</code> and <code>registryFromGitIndex</code> now allow specifying
<code>fetchurlExtraArgs</code> which will be forwarded to the <code>fetchurl</code> invocations for
crates for that registry</li>
</ul>
<h3 id="fixed-31"><a class="header" href="#fixed-31">Fixed</a></h3>
<ul>
<li>Unpacking a git repository now ignores duplicate crates to match cargo's
behavior</li>
<li>Sped up stripping references to source files</li>
<li>Dummy sources now import the <code>core</code> crate more robustly (playing more nicely
with <code>cargo-hakari</code>)</li>
<li>Building a crate's dependencies automatically works for uefi targets</li>
</ul>
<h2 id="090---2022-10-29"><a class="header" href="#090---2022-10-29"><a href="https://github.com/ipetkov/crane/compare/v0.8.0...v0.9.0">0.9.0</a> - 2022-10-29</a></h2>
<h3 id="changed-30"><a class="header" href="#changed-30">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: all setup hooks have been removed from the <code>packages</code> flake
output. They can still be accessed via the <code>lib</code> flake output.</li>
<li><strong>Breaking</strong>: <code>cargoBuild</code> now only runs <code>cargo build</code> in a workspace, tests
are no longer run</li>
<li><strong>Breaking</strong>: <code>buildDepsOnly</code> does not automatically imply the <code>--all-targets</code>
flag when invoking <code>cargo check</code>. Use <code>cargoCheckExtraArgs</code> to control this</li>
<li><code>buildDepsOnly</code> now accepts <code>cargoCheckExtraArgs</code> for passing additional
arguments just to the <code>cargo check</code> invocation. By default <code>--all-targets</code>
will be used</li>
<li><code>buildDepsOnly</code> now accepts <code>cargoTestExtraArgs</code> for passing additional
arguments just to the <code>cargo test</code> invocation</li>
<li><code>buildPackage</code> now delegates to <code>mkCargoDerivation</code> instead of <code>cargoBuild</code></li>
</ul>
<h3 id="fixed-32"><a class="header" href="#fixed-32">Fixed</a></h3>
<ul>
<li><code>crateNameFromCargoToml</code> now takes workspace inheritance into account. If a
crate does not specify <code>package.version</code> in its (root) Cargo.toml but does
specify <code>workspace.package.version</code> then the latter will be returned.</li>
<li>Freestanding (<code>#![no_std]</code>) targets are now supported</li>
</ul>
<h2 id="080---2022-10-09"><a class="header" href="#080---2022-10-09"><a href="https://github.com/ipetkov/crane/compare/v0.7.0...v0.8.0">0.8.0</a> - 2022-10-09</a></h2>
<h3 id="added-16"><a class="header" href="#added-16">Added</a></h3>
<ul>
<li><code>cargoTest</code> can now be used for only running the tests of a workspace</li>
</ul>
<h3 id="changed-31"><a class="header" href="#changed-31">Changed</a></h3>
<ul>
<li><strong>Breaking</strong> (technically): build hooks now expect helper tools (like <code>cargo</code>,
<code>jq</code>, <code>zstd</code>, etc.) to be present on the path instead of substituting a
reference to a (possibly different) executable in the store.</li>
<li><code>mkCargoDerivation</code> now automatically vendors dependencies if <code>cargoVendorDir</code>
is not defined</li>
<li><code>mkCargoDerivation</code> now automatically populates <code>pname</code> and <code>version</code> (via
<code>crateNameFromCargoToml</code>) if they are not specified</li>
<li><code>mkCargoDerivation</code> now defaults to an empty <code>checkPhaseCargoCommand</code> if not
specified</li>
<li><code>cargoAudit</code> now delegates to <code>mkCargoDerivation</code> instead of <code>cargoBuild</code></li>
<li><code>cargoClippy</code> now delegates to <code>mkCargoDerivation</code> instead of <code>cargoBuild</code></li>
<li><code>cargoDoc</code> now delegates to <code>mkCargoDerivation</code> instead of <code>cargoBuild</code></li>
<li><code>cargoFmt</code> now delegates to <code>mkCargoDerivation</code> instead of <code>cargoBuild</code></li>
<li><code>cargoNextest</code> now delegates to <code>mkCargoDerivation</code> instead of <code>cargoBuild</code></li>
<li><code>cargoTarpaulin</code> now delegates to <code>mkCargoDerivation</code> instead of <code>cargoBuild</code></li>
</ul>
<h3 id="fixed-33"><a class="header" href="#fixed-33">Fixed</a></h3>
<ul>
<li>Installing binaries now uses the same version of cargo as was used to build
the package (instead of using whatever version is present in nixpkgs)</li>
</ul>
<h3 id="deprecated"><a class="header" href="#deprecated">Deprecated</a></h3>
<ul>
<li>The <code>packages</code> flake output has been deprecated. All setup hooks can be
accessed via the <code>lib</code> flake output (or via the result of the <code>mkLib</code> flake
output)</li>
</ul>
<h2 id="070---2022-09-28"><a class="header" href="#070---2022-09-28"><a href="https://github.com/ipetkov/crane/compare/v0.6.0...v0.7.0">0.7.0</a> - 2022-09-28</a></h2>
<h2 id="added-17"><a class="header" href="#added-17">Added</a></h2>
<ul>
<li><code>cargoDoc</code> can now be used for building the documentation of a workspace</li>
<li><code>cleanCargoSource</code> can now be used to filter sources to only include cargo and
Rust files (and avoid rebuilds when irrelevant files change).
<code>filterCargoSources</code> is the underlying filter implementation and can be
composed with other filters</li>
<li><code>removeReferencesToVendoredSourcesHook</code> defines a post-install hook which will
remove any references to vendored sources from any installed binaries. Useful
for preventing nix from considering the binaries as having a (runtime)
dependency on said sources</li>
</ul>
<h2 id="changed-32"><a class="header" href="#changed-32">Changed</a></h2>
<ul>
<li><strong>Breaking</strong>: <code>mkCargoDerivation</code> now includes a default <code>configurePhase</code>
which does nothing but run the <code>preConfigure</code> and <code>postConfigure</code> hooks. This
is done to avoid breaking builds by including puts happen to have setup-hooks
which try to claim the configure phase (such as <code>cmake</code>). To get the old
behavior back, set <code>configurePhase = null;</code> in the derivation.</li>
<li><code>mkCargoDerivation</code> (along with any of its callers like <code>cargoBuild</code>,
<code>buildPackage</code>, etc.) now accept a <code>stdenv</code> argument which will override the
default environment (coming from <code>pkgs.stdenv</code>) for that particular derivation</li>
<li><code>mkDummySrc</code> now accepts <code>extraScript</code> which can be used to run a custom
script, and therefore customize what the dummy source contains</li>
<li><code>buildDepsOnly</code> now accepts <code>dummySrc</code> as a way to directly pass in the dummy
source to be used. Automatically derived via <code>args.src</code> if not specified.</li>
</ul>
<h2 id="fixed-34"><a class="header" href="#fixed-34">Fixed</a></h2>
<ul>
<li><code>cargoAudit</code> properly keeps any <code>audit.toml</code> files when cleaning the source</li>
<li><code>buildPackage</code> now has more robust checks to ensure that all references to
vendored sources are removed after installation (which avoids consumers of the
final binaries having to download the sources as well)</li>
<li><code>mkDummySrc</code> how handles build scripts in a manner which ensures cargo runs
the real script later (instead of thinking it has not changed)</li>
</ul>
<h2 id="060---2022-09-07"><a class="header" href="#060---2022-09-07"><a href="https://github.com/ipetkov/crane/compare/v0.5.1...v0.6.0">0.6.0</a> - 2022-09-07</a></h2>
<h3 id="added-18"><a class="header" href="#added-18">Added</a></h3>
<ul>
<li>Added <code>cargoNextest</code> for running tests via <a href="https://nexte.st/">cargo-nextest</a></li>
<li>Added <code>cargoAudit</code> for running <a href="https://crates.io/crates/cargo-audit">cargo-audit</a>
with a provided advisory database instance.</li>
</ul>
<h3 id="changed-33"><a class="header" href="#changed-33">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: the <code>--workspace</code> flag is no longer set for all cargo commands
by default. The previous behavior can be recovered by setting <code>cargoExtraArgs = "--workspace";</code> in any derivation.</li>
<li><strong>Breaking</strong>: the <code>$CARGO_PROFILE</code> environment variable can be used to specify
which cargo-profile all invocations use (by default <code>release</code> will be used).
Technically breaking if the default command was overridden for any derivation;
set <code>CARGO_PROFILE = "";</code> to avoid telling cargo to use a release build.</li>
<li><strong>Breaking</strong>: <code>cargoTarpaulin</code> will use the release profile by default</li>
<li><strong>Breaking</strong>: <code>cargoClippy</code>'s <code>cargoClippyExtraArgs</code> now default to
<code>"--all-targets"</code> instead of being specified as the cargo command itself. If
you have set <code>cargoClippyExtraArgs</code> to an explicit value and wish to retain
the previous behavior you should prepend <code>"--all-targets"</code> to it.</li>
<li><strong>Breaking</strong>: <code>remapSourcePathPrefixHook</code> and the <code>doRemapSourcePathPrefix</code>
option have been removed, and the behavior of <code>buildPackage</code> has been updated
to break false dependencies on the crate sources from the final binaries
(which was the old behavior of the <code>doRemapSourcePathPrefix</code> option). To
disable this behavior, set the <code>doNotRemoveReferencesToVendorDir</code> environment
variable to any non-empty string.</li>
<li>All cargo invocations made during the build are automatically logged</li>
<li>Vendoring git dependencies will throw a descriptive error message if a locked
revision is missing from <code>Cargo.lock</code> and a hint towards resolution</li>
</ul>
<h3 id="fixed-35"><a class="header" href="#fixed-35">Fixed</a></h3>
<ul>
<li><strong>Breaking</strong>: <code>vendorGitDeps</code> will only include crates referenced by the
<code>Cargo.lock</code> file, meaning any extraneous crates which happen to be present in
the git repository will be ignored.</li>
</ul>
<h2 id="051---2022-07-20"><a class="header" href="#051---2022-07-20"><a href="https://github.com/ipetkov/crane/compare/v0.5.0...v0.5.1">0.5.1</a> - 2022-07-20</a></h2>
<h3 id="added-19"><a class="header" href="#added-19">Added</a></h3>
<ul>
<li>Added <code>.overrideToolchain</code> as a convenience for using a custom rust toolchain</li>
</ul>
<h3 id="fixed-36"><a class="header" href="#fixed-36">Fixed</a></h3>
<ul>
<li>Fixed an issue where <code>mkDummySrc</code> would produce incorrect results for filtered
sources: #46</li>
</ul>
<h2 id="050---2022-06-12"><a class="header" href="#050---2022-06-12"><a href="https://github.com/ipetkov/crane/compare/v0.4.1...v0.5.0">0.5.0</a> - 2022-06-12</a></h2>
<h3 id="changed-34"><a class="header" href="#changed-34">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: dropped compatibility for Nix versions below 2.8.1</li>
<li><strong>Breaking</strong>: updated all flake attributes to follow the new <code>.default</code>
guidance as per Nix's warnings. Specifically:
<ul>
<li>Crane's default overlay is now available at <code>.overlays.default</code> (previously
<code>.overlay</code>)</li>
<li>All templates now use <code>{app,devShells,packages}.default</code> as well</li>
</ul>
</li>
<li><strong>Breaking</strong>: <code>lib.fromTOML</code> and <code>lib.toTOML</code> have been removed in favor of
<code>builtins.fromTOML</code></li>
<li>Improved support for consuming <code>crane</code> without using flakes</li>
<li>The <code>nix-std</code> dependency has been dropped</li>
</ul>
<h2 id="041---2022-05-29"><a class="header" href="#041---2022-05-29"><a href="https://github.com/ipetkov/crane/compare/v0.4.0...v0.4.1">0.4.1</a> - 2022-05-29</a></h2>
<h3 id="fixed-37"><a class="header" href="#fixed-37">Fixed</a></h3>
<ul>
<li>Dummy source derivations go to greater lengths to only depend on the files
they consume. Specifying the entire flake source as an input (e.g. via
<code>buildPackage { src = self; }</code>) now avoids rebuilding everything from scratch
whenever <em>any</em> file is changed. #28</li>
</ul>
<h2 id="040---2022-05-10"><a class="header" href="#040---2022-05-10"><a href="https://github.com/ipetkov/crane/compare/v0.3.3...v0.4.0">0.4.0</a> - 2022-05-10</a></h2>
<h3 id="changed-35"><a class="header" href="#changed-35">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: the previously named <code>utils</code> flake input has been renamed to
<code>flake-utils</code></li>
<li><code>buildDepsOnly</code> now adds <code>--all-targets</code> to the default <code>cargo check</code> invocation. This allows caching all artifacts (including from
dev-dependencies) such that tools like clippy don't have to generate them
every time they run.</li>
<li>Templates now use the newer flake format accepted by Nix 2.8 (e.g.
<code>{packages,overlays,devShells}.default</code>, etc.)</li>
</ul>
<h3 id="fixed-38"><a class="header" href="#fixed-38">Fixed</a></h3>
<ul>
<li>Fixed project and template flakes to avoid superfluous follows declaration for
<code>flake-utils</code></li>
<li>Fixed quoting of relative paths to allow building with external sources</li>
</ul>
<h2 id="033---2022-02-24"><a class="header" href="#033---2022-02-24"><a href="https://github.com/ipetkov/crane/compare/v0.3.2...v0.3.3">0.3.3</a> - 2022-02-24</a></h2>
<h3 id="fixed-39"><a class="header" href="#fixed-39">Fixed</a></h3>
<ul>
<li>Use <code>lib.groupBy</code> if <code>builtins.groupBy</code> isn't available (i.e. if a Nix version
earlier than 2.5 is used)</li>
<li>The cross compilation example also hows how to set the <code>HOST_CC</code> environment
variable which may be required by some build scripts to function properly</li>
</ul>
<h2 id="032---2022-02-18"><a class="header" href="#032---2022-02-18"><a href="https://github.com/ipetkov/crane/compare/v0.3.1...v0.3.2">0.3.2</a> - 2022-02-18</a></h2>
<h3 id="fixed-40"><a class="header" href="#fixed-40">Fixed</a></h3>
<ul>
<li>Fixed handling git dependencies whose locked revision is not on the
repository's main branch</li>
</ul>
<h2 id="031---2022-02-17"><a class="header" href="#031---2022-02-17"><a href="https://github.com/ipetkov/crane/compare/v0.3.0...v0.3.1">0.3.1</a> - 2022-02-17</a></h2>
<h3 id="added-20"><a class="header" href="#added-20">Added</a></h3>
<ul>
<li>Added template and example for cross compiling to other platforms</li>
<li>Added template and example for building static binaries using musl</li>
</ul>
<h3 id="changed-36"><a class="header" href="#changed-36">Changed</a></h3>
<ul>
<li><code>cargoClippy</code> and <code>cargoTarpaulin</code> will install cargo artifacts by default (or
install an empty <code>target</code> directory if there are none). This allows for more
easily chaining derivations if doing so is desired.
<ul>
<li>This can be disabled by setting <code>doInstallCargoArtifacts = false;</code> in the
derivation</li>
</ul>
</li>
</ul>
<h3 id="fixed-41"><a class="header" href="#fixed-41">Fixed</a></h3>
<ul>
<li>Fixed an issue where cross compiling would try to needlessly cross compile
rustc and cargo themselves</li>
</ul>
<h2 id="030---2022-02-11"><a class="header" href="#030---2022-02-11"><a href="https://github.com/ipetkov/crane/compare/v0.2.1...v0.3.0">0.3.0</a> - 2022-02-11</a></h2>
<h3 id="added-21"><a class="header" href="#added-21">Added</a></h3>
<ul>
<li><code>downloadCargoPackageFromGit</code> has been added to handle downloading and
unpacking a cargo workspace from a git repository</li>
<li><code>vendorCargoRegistries</code> has been added to handle vendoring crates from all
registries used in a <code>Cargo.lock</code> file</li>
<li><code>vendorGitDeps</code> has been added to handle vendoring crates from all git sources
used in a <code>Cargo.lock</code> file</li>
</ul>
<h3 id="changed-37"><a class="header" href="#changed-37">Changed</a></h3>
<ul>
<li><code>vendorCargoDeps</code> now automatically handles git dependencies by default
<ul>
<li>Git dependencies will be vendored as another source in the output derivation</li>
<li>The cargo configuration is done such that the sources are available to use
when it decides, without overriding that crate for the entire workspace
<ul>
<li>For example, if your workspace contains a crate only used for testing
which has a git dependency of a crate used by other parts of the
workspace, then only that crate will use the git dependency. The rest of
the workspace will continue to use the crates.io version, just like cargo
behaves when used outside of Nix.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="021---2022-02-11"><a class="header" href="#021---2022-02-11"><a href="https://github.com/ipetkov/crane/compare/v0.2.0...v0.2.1">0.2.1</a> - 2022-02-11</a></h2>
<h3 id="changed-38"><a class="header" href="#changed-38">Changed</a></h3>
<ul>
<li><code>cargoFmt</code> will install cargo artifacts by default (or install an empty
<code>target</code> directory if there are none). This allows for more easily chaining
derivations if doing so is desired.
<ul>
<li>This can be disabled by setting <code>doInstallCargoArtifacts = false;</code> in the
derivation</li>
</ul>
</li>
</ul>
<h2 id="020---2022-01-30"><a class="header" href="#020---2022-01-30"><a href="https://github.com/ipetkov/crane/compare/v0.1.0...v0.2.0">0.2.0</a> - 2022-01-30</a></h2>
<h3 id="added-22"><a class="header" href="#added-22">Added</a></h3>
<ul>
<li>Support for alternative cargo registries</li>
</ul>
<h3 id="changed-39"><a class="header" href="#changed-39">Changed</a></h3>
<ul>
<li><code>urlForCargoPackage</code> now takes configured registries into account when
downloading crate sources</li>
<li><strong>Breaking</strong>: <code>vendorCargoDeps</code> now vendors each unique registry as a subdirectory within
the derivation's output. A <code>config.toml</code> file is also placed at the output
root which contains the necessary configurations to point cargo at the
vendored sources.</li>
<li><code>configureCargoVendoredDepsHook</code> is now aware of the updated <code>vendorCargoDeps</code>
output format, and will use the <code>config.toml</code> file it generates if it is
present. Otherwise it will fall back to the previous behavior (which is treat
the entire directory as only vendoring crates.io).</li>
<li>Source vendoring now uses <code>runCommandLocal</code> (instead of <code>runCommand</code>) to
reduce network pressure in trying to fetch results which can quickly be built
locally</li>
<li>Searching for <code>Cargo.toml</code> or <code>.cargo/config.toml</code> files is now done more
efficiently</li>
</ul>
<h2 id="010---2022-01-22"><a class="header" href="#010---2022-01-22">0.1.0 - 2022-01-22</a></h2>
<ul>
<li>First release</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="philosophy"><a class="header" href="#philosophy">Philosophy</a></h2>
<p>Crane is designed around the idea of composing cargo invocations such that they
can take advantage of the artifacts generated in previous invocations. This
allows for both flexible configurations and great caching (à la Cachix) in CI
and local development builds.</p>
<p>Here's how it works at a high level: when a cargo workspace is built its source
is first transformed such that only the dependencies listed by the <code>Cargo.toml</code>
and <code>Cargo.lock</code> files are built, and none of the crate's real source is
included. This allows cargo to build all dependency crates and prevents Nix from
invalidating the derivation whenever the source files are updated. Then, a
second derivation is built, this time using the real source files, which also
imports the cargo artifacts generated in the first step.</p>
<p>This pattern can be used with any arbitrary sequence of commands, regardless of
whether those commands are running additional lints, performing code coverage
analysis, or even generating types from a model schema. Let's take a look at two
examples at how very similar configurations can give us very different behavior!</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="example-one-artifact-reuse"><a class="header" href="#example-one-artifact-reuse">Example One: Artifact Reuse</a></h3>
<p>Suppose we are developing a crate and want to run our CI assurance checks
via <code>nix flake check</code>. Perhaps we want the CI gate to be very strict and block
any changes which raise warnings when run with <code>cargo clippy</code>. Oh, and we want
to enforce some code coverage too!</p>
<p>Except we do not want to push our strict guidelines on any downstream consumers
who may want to build our crate. Suppose they need to build the crate with a
different compiler version (for one reason or another) which comes with a new lint
whose warnings we have not yet addressed. We don't want to make their life
harder, so we want to make sure we do not run <code>cargo clippy</code> as part of the
crate's actual derivation, but at the same time, we don't want to have to
rebuild dependencies from scratch.</p>
<p>Here's how we can set up our flake to achieve our goals:</p>
<pre><code class="language-nix">{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    crane.url = "github:ipetkov/crane";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, crane, flake-utils, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
        craneLib = crane.mkLib pkgs;

        # Common derivation arguments used for all builds
        commonArgs = {
          src = craneLib.cleanCargoSource ./.;
          strictDeps = true;

          buildInputs = with pkgs; [
            # Add extra build inputs here, etc.
            # openssl
          ];

          nativeBuildInputs = with pkgs; [
            # Add extra native build inputs here, etc.
            # pkg-config
          ];
        };

        # Build *just* the cargo dependencies, so we can reuse
        # all of that work (e.g. via cachix) when running in CI
        cargoArtifacts = craneLib.buildDepsOnly (commonArgs // {
          # Additional arguments specific to this derivation can be added here.
          # Be warned that using `//` will not do a deep copy of nested
          # structures
          pname = "mycrate-deps";
        });

        # Run clippy (and deny all warnings) on the crate source,
        # reusing the dependency artifacts (e.g. from build scripts or
        # proc-macros) from above.
        #
        # Note that this is done as a separate derivation so it
        # does not impact building just the crate by itself.
        myCrateClippy = craneLib.cargoClippy (commonArgs // {
          # Again we apply some extra arguments only to this derivation
          # and not every where else. In this case we add some clippy flags
          inherit cargoArtifacts;
          cargoClippyExtraArgs = "--all-targets -- --deny warnings";
        });

        # Build the actual crate itself, reusing the dependency
        # artifacts from above.
        myCrate = craneLib.buildPackage (commonArgs // {
          inherit cargoArtifacts;
        });

        # Also run the crate tests under cargo-tarpaulin so that we can keep
        # track of code coverage
        myCrateCoverage = craneLib.cargoTarpaulin (commonArgs // {
          inherit cargoArtifacts;
        });
      in
      {
        packages.default = myCrate;
        checks = {
         inherit
           # Build the crate as part of `nix flake check` for convenience
           myCrate
           myCrateClippy
           myCrateCoverage;
        };
      });
}
</code></pre>
<p>When we run <code>nix flake check</code> the following will happen:</p>
<ol>
<li>The sources for any dependency crates will be fetched</li>
<li>They will be built without our crate's code and the artifacts propagated</li>
<li>Our crate, the clippy checks, and code coverage collection will be built,
each reusing the same set of artifacts from the initial source-free build. If
enough cores are available to Nix it may build all three derivations
completely in parallel, or schedule them in some arbitrary order.</li>
</ol>
<p>Splitting up our builds like this also gives us the benefit of granular control
over what is rebuilt. Suppose we change our mind and decide to adjust the clippy
flags (e.g. to allow certain lints or forbid others). Doing so will <em>only</em>
rebuild the clippy derivation, without having to rebuild and rerun any of our
other tests!</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="example-two-sequential-builds"><a class="header" href="#example-two-sequential-builds">Example Two: Sequential Builds</a></h3>
<p>Let's take an alternative approach to the previous example. Suppose instead that we
care more about not wasting any resources building certain tests (even if they
would succeed!) if another particular check fails. Perhaps binary substitutes are
readily available so that we do not mind if anyone building from source is bound
by our rules, and we can be sure that all tests have passed as part of the
build.</p>
<pre><code class="language-nix">{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    crane.url = "github:ipetkov/crane";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, crane, flake-utils, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
        craneLib = crane.mkLib pkgs;

        # Common derivation arguments used for all builds
        commonArgs = {
          src = craneLib.cleanCargoSource ./.;
          strictDeps = true;

          buildInputs = with pkgs; [
            # Add extra build inputs here, etc.
            # openssl
          ];

          nativeBuildInputs = with pkgs; [
            # Add extra native build inputs here, etc.
            # pkg-config
          ];
        };

        # Build *just* the cargo dependencies, so we can reuse
        # all of that work (e.g. via cachix) when running in CI
        cargoArtifacts = craneLib.buildDepsOnly (commonArgs // {
          # Additional arguments specific to this derivation can be added here.
          # Be warned that using `//` will not do a deep copy of nested
          # structures
          pname = "mycrate-deps";
        });

        # First, run clippy (and deny all warnings) on the crate source.
        myCrateClippy = craneLib.cargoClippy (commonArgs // {
          # Again we apply some extra arguments only to this derivation
          # and not every where else. In this case we add some clippy flags
          inherit cargoArtifacts;
          cargoClippyExtraArgs = "--all-targets -- --deny warnings";
        });

        # Next, we want to run the tests and collect code-coverage, _but only if
        # the clippy checks pass_ so we do not waste any extra cycles.
        myCrateCoverage = craneLib.cargoTarpaulin (commonArgs // {
          cargoArtifacts = myCrateClippy;
        });

        # Build the actual crate itself, _but only if the previous tests pass_.
        myCrate = craneLib.buildPackage (commonArgs // {
          cargoArtifacts = myCrateCoverage;
        });
      in
      {
        packages.default = myCrate;
        checks = {
         inherit
           # Build the crate as part of `nix flake check` for convenience
           myCrate
           myCrateCoverage;
        };
      });
}
</code></pre>
<p>When we run <code>nix flake check</code> the following will happen:</p>
<ol>
<li>The sources for any dependency crates will be fetched</li>
<li>They will be built without our crate's code and the artifacts propagated</li>
<li>Next the clippy checks will run, reusing the dependency artifacts above.</li>
<li>Next the code coverage tests will run, reusing the artifacts from the clippy
run</li>
<li>Finally the actual crate itself is built</li>
</ol>
<p>In this case we lose the ability to build derivations independently, but we gain
the ability to enforce a strict build order. However, we can easily change our
mind, which would be much more difficult if we had written everything as one
giant derivation.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>The easiest way to get started is to initialize a flake from a template:</p>
<pre><code class="language-sh"># Start with a comprehensive suite of tests
nix flake init -t github:ipetkov/crane#quick-start

# Or if you want something simpler
nix flake init -t github:ipetkov/crane#quick-start-simple

# If you need a custom rust toolchain (e.g. to build WASM targets):
nix flake init -t github:ipetkov/crane#custom-toolchain

# If you need to use another crate registry besides crates.io
nix flake init -t github:ipetkov/crane#alt-registry

# If you need cross-compilation, you can also try out
nix flake init -t github:ipetkov/crane#cross-rust-overlay

# For statically linked binaries using musl
nix flake init -t github:ipetkov/crane#cross-musl

# If you are building a WASM webapp with trunk
nix flake init -t github:ipetkov/crane#trunk

# If you are building a workspace with trunk member
nix flake init -t github:ipetkov/crane#trunk-workspace

# If you would like to perform end to end testing of a webapp
nix flake init -t github:ipetkov/crane#end-to-end-testing
</code></pre>
<p>For an even more lean, no frills set up, create a <code>flake.nix</code> file with the
following contents at the root of your cargo workspace:</p>
<pre><code class="language-nix">{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    crane.url = "github:ipetkov/crane";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, crane, flake-utils, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
        craneLib = crane.mkLib pkgs;
      in
    {
      packages.default = craneLib.buildPackage {
        src = craneLib.cleanCargoSource ./.;

        # Add extra inputs here or any other derivation settings
        # doCheck = true;
        # buildInputs = [];
        # nativeBuildInputs = [];
      };
    });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>To build a cargo project with a comprehensive test suite, run the following in a
fresh directory:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#quick-start
</code></pre>
<p>Alternatively, if you have an existing project already, copy and paste the
following <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  description = "Build a cargo project";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";

    advisory-db = {
      url = "github:rustsec/advisory-db";
      flake = false;
    };
  };

  outputs =
    {
      self,
      nixpkgs,
      crane,
      flake-utils,
      advisory-db,
      ...
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = nixpkgs.legacyPackages.${system};

        inherit (pkgs) lib;

        craneLib = crane.mkLib pkgs;
        src = craneLib.cleanCargoSource ./.;

        # Common arguments can be set here to avoid repeating them later
        commonArgs = {
          inherit src;
          strictDeps = true;

          buildInputs = [
            # Add additional build inputs here
          ]
          ++ lib.optionals pkgs.stdenv.isDarwin [
            # Additional darwin specific inputs can be set here
            pkgs.libiconv
          ];

          # Additional environment variables can be set directly
          # MY_CUSTOM_VAR = "some value";
        };

        # Build *just* the cargo dependencies, so we can reuse
        # all of that work (e.g. via cachix) when running in CI
        cargoArtifacts = craneLib.buildDepsOnly commonArgs;

        # Build the actual crate itself, reusing the dependency
        # artifacts from above.
        my-crate = craneLib.buildPackage (
          commonArgs
          // {
            inherit cargoArtifacts;
          }
        );
      in
      {
        checks = {
          # Build the crate as part of `nix flake check` for convenience
          inherit my-crate;

          # Run clippy (and deny all warnings) on the crate source,
          # again, reusing the dependency artifacts from above.
          #
          # Note that this is done as a separate derivation so that
          # we can block the CI if there are issues here, but not
          # prevent downstream consumers from building our crate by itself.
          my-crate-clippy = craneLib.cargoClippy (
            commonArgs
            // {
              inherit cargoArtifacts;
              cargoClippyExtraArgs = "--all-targets -- --deny warnings";
            }
          );

          my-crate-doc = craneLib.cargoDoc (
            commonArgs
            // {
              inherit cargoArtifacts;
              # This can be commented out or tweaked as necessary, e.g. set to
              # `--deny rustdoc::broken-intra-doc-links` to only enforce that lint
              env.RUSTDOCFLAGS = "--deny warnings";
            }
          );

          # Check formatting
          my-crate-fmt = craneLib.cargoFmt {
            inherit src;
          };

          my-crate-toml-fmt = craneLib.taploFmt {
            src = pkgs.lib.sources.sourceFilesBySuffices src [ ".toml" ];
            # taplo arguments can be further customized below as needed
            # taploExtraArgs = "--config ./taplo.toml";
          };

          # Audit dependencies
          my-crate-audit = craneLib.cargoAudit {
            inherit src advisory-db;
          };

          # Audit licenses
          my-crate-deny = craneLib.cargoDeny {
            inherit src;
          };

          # Run tests with cargo-nextest
          # Consider setting `doCheck = false` on `my-crate` if you do not want
          # the tests to run twice
          my-crate-nextest = craneLib.cargoNextest (
            commonArgs
            // {
              inherit cargoArtifacts;
              partitions = 1;
              partitionType = "count";
              cargoNextestPartitionsExtraArgs = "--no-tests=pass";
            }
          );
        };

        packages = {
          default = my-crate;
        };

        apps.default = flake-utils.lib.mkApp {
          drv = my-crate;
        };

        devShells.default = craneLib.devShell {
          # Inherit inputs from checks.
          checks = self.checks.${system};

          # Additional dev-shell environment variables can be set directly
          # MY_CUSTOM_DEVELOPMENT_VAR = "something else";

          # Extra inputs can be added here; cargo and rustc are provided by default.
          packages = [
            # pkgs.ripgrep
          ];
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>To build a cargo project without extra tests, run the following in a fresh
directory:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#quick-start-simple
</code></pre>
<p>Alternatively, if you have an existing project already, copy and paste the
following <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  description = "Build a cargo project without extra checks";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs =
    {
      self,
      nixpkgs,
      crane,
      flake-utils,
      ...
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = nixpkgs.legacyPackages.${system};

        craneLib = crane.mkLib pkgs;

        # Common arguments can be set here to avoid repeating them later
        # Note: changes here will rebuild all dependency crates
        commonArgs = {
          src = craneLib.cleanCargoSource ./.;
          strictDeps = true;

          buildInputs = [
            # Add additional build inputs here
          ]
          ++ pkgs.lib.optionals pkgs.stdenv.isDarwin [
            # Additional darwin specific inputs can be set here
            pkgs.libiconv
          ];
        };

        my-crate = craneLib.buildPackage (
          commonArgs
          // {
            cargoArtifacts = craneLib.buildDepsOnly commonArgs;

            # Additional environment variables or build phases/hooks can be set
            # here *without* rebuilding all dependency crates
            # MY_CUSTOM_VAR = "some value";
          }
        );
      in
      {
        checks = {
          inherit my-crate;
        };

        packages.default = my-crate;

        apps.default = flake-utils.lib.mkApp {
          drv = my-crate;
        };

        devShells.default = craneLib.devShell {
          # Inherit inputs from checks.
          checks = self.checks.${system};

          # Additional dev-shell environment variables can be set directly
          # MY_CUSTOM_DEVELOPMENT_VAR = "something else";

          # Extra inputs can be added here; cargo and rustc are provided by default.
          packages = [
            # pkgs.ripgrep
          ];
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>Note that it is <em>highly</em> recommended to use something like <code>cargo-hakari</code>
to avoid cache misses when building various workspace crates.</p>
</blockquote>
<p>To build a cargo workspace with a comprehensive test suite, run the following in
a fresh directory:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#quick-start-workspace
</code></pre>
<p>Alternatively, if you have an existing project already, copy and paste the
following <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  description = "Build a cargo workspace";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";

    advisory-db = {
      url = "github:rustsec/advisory-db";
      flake = false;
    };
  };

  outputs =
    {
      self,
      nixpkgs,
      crane,
      flake-utils,
      advisory-db,
      ...
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = nixpkgs.legacyPackages.${system};

        inherit (pkgs) lib;

        craneLib = crane.mkLib pkgs;
        src = craneLib.cleanCargoSource ./.;

        # Common arguments can be set here to avoid repeating them later
        commonArgs = {
          inherit src;
          strictDeps = true;

          buildInputs = [
            # Add additional build inputs here
          ]
          ++ lib.optionals pkgs.stdenv.isDarwin [
            # Additional darwin specific inputs can be set here
            pkgs.libiconv
          ];

          # Additional environment variables can be set directly
          # MY_CUSTOM_VAR = "some value";
        };

        # Build *just* the cargo dependencies (of the entire workspace),
        # so we can reuse all of that work (e.g. via cachix) when running in CI
        # It is *highly* recommended to use something like cargo-hakari to avoid
        # cache misses when building individual top-level-crates
        cargoArtifacts = craneLib.buildDepsOnly commonArgs;

        individualCrateArgs = commonArgs // {
          inherit cargoArtifacts;
          inherit (craneLib.crateNameFromCargoToml { inherit src; }) version;
          # NB: we disable tests since we'll run them all via cargo-nextest
          doCheck = false;
        };

        fileSetForCrate =
          crate:
          lib.fileset.toSource {
            root = ./.;
            fileset = lib.fileset.unions [
              ./Cargo.toml
              ./Cargo.lock
              (craneLib.fileset.commonCargoSources ./crates/my-common)
              (craneLib.fileset.commonCargoSources ./crates/my-workspace-hack)
              (craneLib.fileset.commonCargoSources crate)
            ];
          };

        # Build the top-level crates of the workspace as individual derivations.
        # This allows consumers to only depend on (and build) only what they need.
        # Though it is possible to build the entire workspace as a single derivation,
        # so this is left up to you on how to organize things
        #
        # Note that the cargo workspace must define `workspace.members` using wildcards,
        # otherwise, omitting a crate (like we do below) will result in errors since
        # cargo won't be able to find the sources for all members.
        my-cli = craneLib.buildPackage (
          individualCrateArgs
          // {
            pname = "my-cli";
            cargoExtraArgs = "-p my-cli";
            src = fileSetForCrate ./crates/my-cli;
          }
        );
        my-server = craneLib.buildPackage (
          individualCrateArgs
          // {
            pname = "my-server";
            cargoExtraArgs = "-p my-server";
            src = fileSetForCrate ./crates/my-server;
          }
        );
      in
      {
        checks = {
          # Build the crates as part of `nix flake check` for convenience
          inherit my-cli my-server;

          # Run clippy (and deny all warnings) on the workspace source,
          # again, reusing the dependency artifacts from above.
          #
          # Note that this is done as a separate derivation so that
          # we can block the CI if there are issues here, but not
          # prevent downstream consumers from building our crate by itself.
          my-workspace-clippy = craneLib.cargoClippy (
            commonArgs
            // {
              inherit cargoArtifacts;
              cargoClippyExtraArgs = "--all-targets -- --deny warnings";
            }
          );

          my-workspace-doc = craneLib.cargoDoc (
            commonArgs
            // {
              inherit cargoArtifacts;
              # This can be commented out or tweaked as necessary, e.g. set to
              # `--deny rustdoc::broken-intra-doc-links` to only enforce that lint
              env.RUSTDOCFLAGS = "--deny warnings";
            }
          );

          # Check formatting
          my-workspace-fmt = craneLib.cargoFmt {
            inherit src;
          };

          my-workspace-toml-fmt = craneLib.taploFmt {
            src = pkgs.lib.sources.sourceFilesBySuffices src [ ".toml" ];
            # taplo arguments can be further customized below as needed
            # taploExtraArgs = "--config ./taplo.toml";
          };

          # Audit dependencies
          my-workspace-audit = craneLib.cargoAudit {
            inherit src advisory-db;
          };

          # Audit licenses
          my-workspace-deny = craneLib.cargoDeny {
            inherit src;
          };

          # Run tests with cargo-nextest
          # Consider setting `doCheck = false` on other crate derivations
          # if you do not want the tests to run twice
          my-workspace-nextest = craneLib.cargoNextest (
            commonArgs
            // {
              inherit cargoArtifacts;
              partitions = 1;
              partitionType = "count";
              cargoNextestPartitionsExtraArgs = "--no-tests=pass";
            }
          );

          # Ensure that cargo-hakari is up to date
          my-workspace-hakari = craneLib.mkCargoDerivation {
            inherit src;
            pname = "my-workspace-hakari";
            cargoArtifacts = null;
            doInstallCargoArtifacts = false;

            buildPhaseCargoCommand = ''
              cargo hakari generate --diff  # workspace-hack Cargo.toml is up-to-date
              cargo hakari manage-deps --dry-run  # all workspace crates depend on workspace-hack
              cargo hakari verify
            '';

            nativeBuildInputs = [
              pkgs.cargo-hakari
            ];
          };
        };

        packages = {
          inherit my-cli my-server;
        };

        apps = {
          my-cli = flake-utils.lib.mkApp {
            drv = my-cli;
          };
          my-server = flake-utils.lib.mkApp {
            drv = my-server;
          };
        };

        devShells.default = craneLib.devShell {
          # Inherit inputs from checks.
          checks = self.checks.${system};

          # Additional dev-shell environment variables can be set directly
          # MY_CUSTOM_DEVELOPMENT_VAR = "something else";

          # Extra inputs can be added here; cargo and rustc are provided by default.
          packages = [
            pkgs.cargo-hakari
          ];
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>To build a cargo project with a custom toolchain (e.g. WASM builds), run the
following in a fresh directory:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#custom-toolchain
</code></pre>
<p>Alternatively, if you have an existing project already, copy and paste the
following <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  description = "Build a cargo project with a custom toolchain";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";

    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs =
    {
      self,
      nixpkgs,
      crane,
      flake-utils,
      rust-overlay,
      ...
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = import nixpkgs {
          inherit system;
          overlays = [ (import rust-overlay) ];
        };

        # NB: we don't need to overlay our custom toolchain for the *entire*
        # pkgs (which would require rebuidling anything else which uses rust).
        # Instead, we just want to update the scope that crane will use by appending
        # our specific toolchain there.
        craneLib = (crane.mkLib pkgs).overrideToolchain (
          p:
          p.rust-bin.stable.latest.default.override {
            targets = [ "wasm32-wasip1" ];
          }
        );

        my-crate = craneLib.buildPackage {
          src = craneLib.cleanCargoSource ./.;
          strictDeps = true;

          cargoExtraArgs = "--target wasm32-wasip1";

          # Tests currently need to be run via `cargo wasi` which
          # isn't packaged in nixpkgs yet...
          doCheck = false;

          buildInputs = [
            # Add additional build inputs here
          ]
          ++ pkgs.lib.optionals pkgs.stdenv.isDarwin [
            # Additional darwin specific inputs can be set here
            pkgs.libiconv
          ];
        };
      in
      {
        checks = {
          inherit my-crate;
        };

        packages.default = my-crate;

        apps.default = flake-utils.lib.mkApp {
          drv = pkgs.writeShellScriptBin "my-app" ''
            ${pkgs.wasmtime}/bin/wasmtime run ${my-crate}/bin/custom-toolchain.wasm
          '';
        };

        devShells.default = craneLib.devShell {
          # Inherit inputs from checks.
          checks = self.checks.${system};

          # Extra inputs can be added here; cargo and rustc are provided by default
          # from the toolchain that was specified earlier.
          packages = [
          ];
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>To build a cargo project which uses another crate registry, run the following in
a fresh directory:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#alt-registry
</code></pre>
<p>Alternatively, if you have an existing project already:</p>
<ol>
<li>Ensure that declaration of the registry and its index url are present in
<code>.cargo/config.toml</code></li>
<li>Either commit <code>.cargo/config.toml</code> or ensure it is staged in git (<code>git add -N .cargo/config.toml</code>)</li>
<li>Copy and paste the following <code>flake.nix</code>:</li>
</ol>
<pre><code class="language-nix">{
  description = "Build a cargo project with alternative crate registries";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils = {
      url = "github:numtide/flake-utils";
    };
  };

  outputs =
    {
      self,
      nixpkgs,
      crane,
      flake-utils,
      ...
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = nixpkgs.legacyPackages.${system};

        craneLibOrig = crane.mkLib pkgs;
        craneLib = craneLibOrig.appendCrateRegistries [
          # Automatically infer the download URL from the registry's index
          #
          # Note that this approach requires checking out the full index at the specified revision
          # and adding a copy to the Nix store.
          #
          # Also note that the specified git revision _does not need to track updates to the index
          # itself_ as long as the pinned revision contains the most recent version of the
          # registry's `config.json` file. In other words, this commit revision only needs to be
          # updated if the `config.json` file changes the download endpoint for this registry.
          (craneLibOrig.registryFromGitIndex {
            indexUrl = "https://github.com/Hirevo/alexandrie-index";
            rev = "90df25daf291d402d1ded8c32c23d5e1498c6725";
            fetchurlExtraArgs = {
              # Extra parameters which will be passed to the fetchurl invocation for each crate
            };
          })

          # If the registry in question is a sparse index, instead configure as
          #(craneLibOrig.registryFromSparse {
          #  indexUrl = "https://index.crates.io";
          #  # where the sha256 is the sha256 of https://index.crates.io/config.json.
          #  configSha256 = "d16740883624df970adac38c70e35cf077a2a105faa3862f8f99a65da96b14a3";
          #  fetchurlExtraArgs = {
          #    # Extra parameters which will be passed to the fetchurl invocation for each crate
          #    curlOptsList = [
          #      "--header"
          #      "Authorization: API_TOKEN"
          #    ];
          #  };
          #})

          # As a more lightweight alternative, the `dl` endpoint of the registry's `config.json`
          # file can be copied here to avoid needing to copy the index to the Nix store.
          # (craneLibOrig.registryFromDownloadUrl {
          #   indexUrl = "https://github.com/Hirevo/alexandrie-index";
          #   dl = "https://crates.polomack.eu/api/v1/crates/{crate}/{version}/download";
          #   fetchurlExtraArgs = {
          #     # Extra parameters which will be passed to the fetchurl invocation for each crate
          #   };
          # })
        ];

        my-crate = craneLib.buildPackage {
          src = craneLib.cleanCargoSource ./.;
          strictDeps = true;

          buildInputs = [
            # Add additional build inputs here
            pkgs.openssl
          ];

          # Specific to our example, but not always necessary in the general case.
          nativeBuildInputs = [
            pkgs.pkg-config
          ];
        };
      in
      {
        checks = {
          # Build the crate as part of `nix flake check` for convenience
          inherit my-crate;
        };

        packages.default = my-crate;

        apps.default = flake-utils.lib.mkApp {
          drv = my-crate;
        };

        devShells.default = craneLib.devShell {
          # Inherit inputs from checks.
          checks = self.checks.${system};

          # Additional dev-shell environment variables can be set directly
          # MY_CUSTOM_DEVELOPMENT_VAR = "something else";

          # Extra inputs can be added here; cargo and rustc are provided by default.
          packages = [
            # pkgs.ripgrep
          ];
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>To build a cargo project while also compiling the standard library or other
crates distributed with the Rust toolchain, run the following in a fresh
directory:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#build-std
</code></pre>
<p>Alternatively, if you have an existing project already, copy and paste the
following <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  description = "Build a cargo project while also compiling the standard library";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";

    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs =
    {
      self,
      nixpkgs,
      crane,
      flake-utils,
      rust-overlay,
      ...
    }:
    flake-utils.lib.eachSystem [ "x86_64-linux" ] (
      system:
      let
        pkgs = import nixpkgs {
          inherit system;
          overlays = [ (import rust-overlay) ];
        };

        rustToolchainFor =
          p:
          p.rust-bin.selectLatestNightlyWith (
            toolchain:
            toolchain.default.override {
              extensions = [ "rust-src" ];
              targets = [ "x86_64-unknown-linux-gnu" ];
            }
          );
        rustToolchain = rustToolchainFor pkgs;

        # NB: we don't need to overlay our custom toolchain for the *entire*
        # pkgs (which would require rebuidling anything else which uses rust).
        # Instead, we just want to update the scope that crane will use by appending
        # our specific toolchain there.
        craneLib = (crane.mkLib pkgs).overrideToolchain rustToolchainFor;

        src = craneLib.cleanCargoSource ./.;

        my-crate = craneLib.buildPackage {
          inherit src;
          strictDeps = true;

          cargoVendorDir = craneLib.vendorMultipleCargoDeps {
            inherit (craneLib.findCargoFiles src) cargoConfigs;
            cargoLockList = [
              ./Cargo.lock

              # Unfortunately this approach requires IFD (import-from-derivation)
              # otherwise Nix will refuse to read the Cargo.lock from our toolchain
              # (unless we build with `--impure`).
              #
              # Another way around this is to manually copy the rustlib `Cargo.lock`
              # to the repo and import it with `./path/to/rustlib/Cargo.lock` which
              # will avoid IFD entirely but will require manually keeping the file
              # up to date!
              "${rustToolchain.passthru.availableComponents.rust-src}/lib/rustlib/src/rust/library/Cargo.lock"
            ];
          };

          cargoExtraArgs = "-Z build-std --target x86_64-unknown-linux-gnu";

          buildInputs = [
            # Add additional build inputs here
          ];
        };
      in
      {
        checks = {
          inherit my-crate;
        };

        packages.default = my-crate;

        devShells.default = craneLib.devShell {
          # Inherit inputs from checks.
          checks = self.checks.${system};

          # Extra inputs can be added here; cargo and rustc are provided by default
          # from the toolchain that was specified earlier.
          packages = [
          ];
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>To cross compile a rust project using <code>oxalica/rust-overlay</code>, run the following
in a fresh directory:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#cross-rust-overlay
</code></pre>
<p>Alternatively, if you have an existing project already, copy and paste the
following <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  description = "Cross compiling a rust program using rust-overlay";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";

    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs =
    {
      nixpkgs,
      crane,
      flake-utils,
      rust-overlay,
      ...
    }:
    flake-utils.lib.eachDefaultSystem (
      localSystem:
      let
        # Replace with the system you want to build for
        crossSystem = "aarch64-linux";

        pkgs = import nixpkgs {
          inherit crossSystem localSystem;
          overlays = [ (import rust-overlay) ];
        };

        craneLib = (crane.mkLib pkgs).overrideToolchain (p: p.rust-bin.stable.latest.default);

        # Note: we have to use the `callPackage` approach here so that Nix
        # can "splice" the packages in such a way that dependencies are
        # compiled for the appropriate targets. If we did not do this, we
        # would have to manually specify things like
        # `nativeBuildInputs = with pkgs.pkgsBuildHost; [ someDep ];` or
        # `buildInputs = with pkgs.pkgsHostHost; [ anotherDep ];`.
        #
        # Normally you can stick this function into its own file and pass
        # its path to `callPackage`.
        crateExpression =
          {
            openssl,
            libiconv,
            lib,
            pkg-config,
            stdenv,
          }:
          craneLib.buildPackage {
            src = craneLib.cleanCargoSource ./.;
            strictDeps = true;

            # Dependencies which need to be build for the current platform
            # on which we are doing the cross compilation. In this case,
            # pkg-config needs to run on the build platform so that the build
            # script can find the location of openssl. Note that we don't
            # need to specify the rustToolchain here since it was already
            # overridden above.
            nativeBuildInputs = [
              pkg-config
            ]
            ++ lib.optionals stdenv.buildPlatform.isDarwin [
              libiconv
            ];

            # Dependencies which need to be built for the platform on which
            # the binary will run. In this case, we need to compile openssl
            # so that it can be linked with our executable.
            buildInputs = [
              # Add additional build inputs here
              openssl
            ];
          };

        # Assuming the above expression was in a file called myCrate.nix
        # this would be defined as:
        # my-crate = pkgs.callPackage ./myCrate.nix { };
        my-crate = pkgs.callPackage crateExpression { };
      in
      {
        checks = {
          inherit my-crate;
        };

        packages.default = my-crate;

        apps.default = flake-utils.lib.mkApp {
          drv = pkgs.writeScriptBin "my-app" ''
            ${pkgs.pkgsBuildBuild.qemu}/bin/qemu-aarch64 ${my-crate}/bin/cross-rust-overlay
          '';
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>To build a cargo project with musl to crate statically linked binaries, run the
following in a fresh directory:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#cross-musl
</code></pre>
<p>Alternatively, if you have an existing project already, copy and paste the
following <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  description = "Building static binaries with musl";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";

    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs =
    {
      nixpkgs,
      crane,
      flake-utils,
      rust-overlay,
      ...
    }:
    flake-utils.lib.eachSystem [ "x86_64-linux" ] (
      system:
      let
        pkgs = import nixpkgs {
          inherit system;
          overlays = [ (import rust-overlay) ];
        };

        craneLib = (crane.mkLib pkgs).overrideToolchain (
          p:
          p.rust-bin.stable.latest.default.override {
            targets = [ "x86_64-unknown-linux-musl" ];
          }
        );

        my-crate = craneLib.buildPackage {
          src = craneLib.cleanCargoSource ./.;
          strictDeps = true;

          CARGO_BUILD_TARGET = "x86_64-unknown-linux-musl";
          CARGO_BUILD_RUSTFLAGS = "-C target-feature=+crt-static";
        };
      in
      {
        checks = {
          inherit my-crate;
        };

        packages.default = my-crate;
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>To cross compiling a rust program for windows, run the following in a fresh
directory:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#cross-windows
</code></pre>
<p>Alternatively, if you have an existing project already, copy and paste the
following <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  description = "Cross compiling a rust program for windows";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";

    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs =
    {
      nixpkgs,
      crane,
      flake-utils,
      rust-overlay,
      ...
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = import nixpkgs {
          overlays = [ (import rust-overlay) ];
          localSystem = system;
          crossSystem = {
            config = "x86_64-w64-mingw32";
            libc = "msvcrt";
          };
        };

        craneLib = (crane.mkLib pkgs).overrideToolchain (
          p:
          p.rust-bin.stable.latest.default.override {
            targets = [ "x86_64-pc-windows-gnu" ];
          }
        );

        my-crate = craneLib.buildPackage {
          src = craneLib.cleanCargoSource ./.;

          strictDeps = true;
        };
      in
      {
        packages = {
          inherit my-crate;
          default = my-crate;
        };

        checks = {
          inherit my-crate;
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="https://trunkrs.dev">Trunk</a> is a tool that allow you to build web apps using Rust and webassembly, including compiling scss, and distributing other assets.</p>
<p>Being a more specialized tool, it comes with some constraints that must be noted when using it in combination with crane:</p>
<ul>
<li>Your Toolchain must have the <code>wasm32-unknown-unknown</code> target installed (See: <a href="examples/../custom-toolchain.html">Custom toolchain</a>)</li>
<li>For <code>craneLib.buildDepsOnly</code> to work you will need to set the build target (See: <a href="examples/../API.html#libbuilddepsonly">API Reference</a>)</li>
<li><code>craneLib.filterCargoSources</code> will remove html, css, your assets folder, so you need to modify the source filtering function (See: <a href="examples/../source-filtering.html">Source filtering</a>)</li>
<li>You will need to set <code>wasm-bindgen-cli</code> to a version that matches your Cargo.lock file. (See examples)</li>
</ul>
<p>For a quick-start run the following in a fresh directory:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#trunk
</code></pre>
<p>Alternatively, if you have an existing project already, copy and paste the
following <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  description = "Build a cargo project";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";

    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs =
    {
      self,
      nixpkgs,
      crane,
      flake-utils,
      rust-overlay,
      ...
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = import nixpkgs {
          inherit system;
          overlays = [ (import rust-overlay) ];
        };

        inherit (pkgs) lib;

        rustToolchainFor =
          p:
          p.rust-bin.stable.latest.default.override {
            # Set the build targets supported by the toolchain,
            # wasm32-unknown-unknown is required for trunk
            targets = [ "wasm32-unknown-unknown" ];
          };
        craneLib = (crane.mkLib pkgs).overrideToolchain rustToolchainFor;

        # When filtering sources, we want to allow assets other than .rs files
        unfilteredRoot = ./.; # The original, unfiltered source
        src = lib.fileset.toSource {
          root = unfilteredRoot;
          fileset = lib.fileset.unions [
            # Default files from crane (Rust and cargo files)
            (craneLib.fileset.commonCargoSources unfilteredRoot)
            (lib.fileset.fileFilter (
              file:
              lib.any file.hasExt [
                "html"
                "scss"
              ]
            ) unfilteredRoot)
            # Example of a folder for images, icons, etc
            (lib.fileset.maybeMissing ./assets)
          ];
        };

        # Common arguments can be set here to avoid repeating them later
        commonArgs = {
          inherit src;
          strictDeps = true;
          # We must force the target, otherwise cargo will attempt to use your native target
          CARGO_BUILD_TARGET = "wasm32-unknown-unknown";

          buildInputs = [
            # Add additional build inputs here
          ]
          ++ lib.optionals pkgs.stdenv.isDarwin [
            # Additional darwin specific inputs can be set here
            pkgs.libiconv
          ];
        };

        # Build *just* the cargo dependencies, so we can reuse
        # all of that work (e.g. via cachix) when running in CI
        cargoArtifacts = craneLib.buildDepsOnly (
          commonArgs
          // {
            # You cannot run cargo test on a wasm build
            doCheck = false;
          }
        );

        # Build the actual crate itself, reusing the dependency
        # artifacts from above.
        # This derivation is a directory you can put on a webserver.
        my-app = craneLib.buildTrunkPackage (
          commonArgs
          // {
            inherit cargoArtifacts;
            # The version of wasm-bindgen-cli here must match the one from Cargo.lock.
            # When updating to a new version replace the hash values with lib.fakeHash,
            # then try to do a build, which will fail but will print out the correct value
            # for `hash`. Replace the value and then repeat the process but this time the
            # printed value will be for the second `hash` below
            wasm-bindgen-cli = pkgs.buildWasmBindgenCli rec {
              src = pkgs.fetchCrate {
                pname = "wasm-bindgen-cli";
                version = "0.2.100";
                hash = "sha256-3RJzK7mkYFrs7C/WkhW9Rr4LdP5ofb2FdYGz1P7Uxog=";
                # hash = lib.fakeHash;
              };

              cargoDeps = pkgs.rustPlatform.fetchCargoVendor {
                inherit src;
                inherit (src) pname version;
                hash = "sha256-qsO12332HSjWCVKtf1cUePWWb9IdYUmT+8OPj/XP2WE=";
                # hash = lib.fakeHash;
              };
            };
          }
        );

        # Quick example on how to serve the app,
        # This is just an example, not useful for production environments
        serve-app = pkgs.writeShellScriptBin "serve-app" ''
          ${pkgs.python3Minimal}/bin/python3 -m http.server --directory ${my-app} 8000
        '';
      in
      {
        checks = {
          # Build the crate as part of `nix flake check` for convenience
          inherit my-app;

          # Run clippy (and deny all warnings) on the crate source,
          # again, reusing the dependency artifacts from above.
          #
          # Note that this is done as a separate derivation so that
          # we can block the CI if there are issues here, but not
          # prevent downstream consumers from building our crate by itself.
          my-app-clippy = craneLib.cargoClippy (
            commonArgs
            // {
              inherit cargoArtifacts;
              cargoClippyExtraArgs = "--all-targets -- --deny warnings";
            }
          );

          # Check formatting
          my-app-fmt = craneLib.cargoFmt {
            inherit src;
          };
        };

        packages.default = my-app;

        apps.default = flake-utils.lib.mkApp {
          drv = serve-app;
        };

        devShells.default = craneLib.devShell {
          # Inherit inputs from checks.
          checks = self.checks.${system};

          # Additional dev-shell environment variables can be set directly
          # MY_CUSTOM_DEVELOPMENT_VAR = "something else";

          # Extra inputs can be added here; cargo and rustc are provided by default.
          packages = [
            pkgs.trunk
          ];
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="https://trunkrs.dev">Trunk</a> is a tool that allow you to build web apps using Rust and webassembly, including compiling scss, and distributing other assets.
It can be used in conjunction with any of Rust's web frameworks for the development of full stack web applications.</p>
<p>In this example we have a workspace with three members:</p>
<ul>
<li>client: a Yew application compiled using Trunk</li>
<li>server: a Axum server built using Cargo</li>
<li>shared: a library that contains types to be imported in both the client and server</li>
</ul>
<p>For a quick-start run the following in a fresh directory:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#trunk-workspace
</code></pre>
<p>Alternatively, if you have an existing project already, copy and paste the
following <code>flake.nix</code> and modify it to build your workspace's packages:</p>
<pre><code class="language-nix">{
  description = "Build a cargo project";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";

    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs =
    {
      self,
      nixpkgs,
      crane,
      flake-utils,
      rust-overlay,
      ...
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = import nixpkgs {
          inherit system;
          overlays = [ (import rust-overlay) ];
        };

        inherit (pkgs) lib;

        rustToolchainFor =
          p:
          p.rust-bin.stable.latest.default.override {
            # Set the build targets supported by the toolchain,
            # wasm32-unknown-unknown is required for trunk.
            targets = [ "wasm32-unknown-unknown" ];
          };
        craneLib = (crane.mkLib pkgs).overrideToolchain rustToolchainFor;

        # When filtering sources, we want to allow assets other than .rs files
        unfilteredRoot = ./.; # The original, unfiltered source
        src = lib.fileset.toSource {
          root = unfilteredRoot;
          fileset = lib.fileset.unions [
            # Default files from crane (Rust and cargo files)
            (craneLib.fileset.commonCargoSources unfilteredRoot)
            (lib.fileset.fileFilter (
              file:
              lib.any file.hasExt [
                "html"
                "scss"
              ]
            ) unfilteredRoot)
            # Example of a folder for images, icons, etc
            (lib.fileset.maybeMissing ./assets)
          ];
        };

        # Arguments to be used by both the client and the server
        # When building a workspace with crane, it's a good idea
        # to set "pname" and "version".
        commonArgs = {
          inherit src;
          strictDeps = true;

          buildInputs = [
            # Add additional build inputs here
          ]
          ++ lib.optionals pkgs.stdenv.isDarwin [
            # Additional darwin specific inputs can be set here
            pkgs.libiconv
          ];
        };

        # Native packages

        nativeArgs = commonArgs // {
          pname = "trunk-workspace-native";
        };

        # Build *just* the cargo dependencies, so we can reuse
        # all of that work (e.g. via cachix) when running in CI
        cargoArtifacts = craneLib.buildDepsOnly nativeArgs;

        # Simple JSON API that can be queried by the client
        myServer = craneLib.buildPackage (
          nativeArgs
          // {
            inherit cargoArtifacts;
            # The server needs to know where the client's dist dir is to
            # serve it, so we pass it as an environment variable at build time
            CLIENT_DIST = myClient;
          }
        );

        # Wasm packages

        # it's not possible to build the server on the
        # wasm32 target, so we only build the client.
        wasmArgs = commonArgs // {
          pname = "trunk-workspace-wasm";
          cargoExtraArgs = "--package=client";
          CARGO_BUILD_TARGET = "wasm32-unknown-unknown";
        };

        cargoArtifactsWasm = craneLib.buildDepsOnly (
          wasmArgs
          // {
            doCheck = false;
          }
        );

        # Build the frontend of the application.
        # This derivation is a directory you can put on a webserver.
        myClient = craneLib.buildTrunkPackage (
          wasmArgs
          // {
            pname = "trunk-workspace-client";
            cargoArtifacts = cargoArtifactsWasm;
            # Trunk expects the current directory to be the crate to compile
            preBuild = ''
              cd ./client
            '';
            # After building, move the `dist` artifacts and restore the working directory
            postBuild = ''
              mv ./dist ..
              cd ..
            '';
            # The version of wasm-bindgen-cli here must match the one from Cargo.lock.
            # When updating to a new version replace the hash values with lib.fakeHash,
            # then try to do a build, which will fail but will print out the correct value
            # for `hash`. Replace the value and then repeat the process but this time the
            # printed value will be for the second `hash` below
            wasm-bindgen-cli = pkgs.buildWasmBindgenCli rec {
              src = pkgs.fetchCrate {
                pname = "wasm-bindgen-cli";
                version = "0.2.100";
                hash = "sha256-3RJzK7mkYFrs7C/WkhW9Rr4LdP5ofb2FdYGz1P7Uxog=";
                # hash = lib.fakeHash;
              };

              cargoDeps = pkgs.rustPlatform.fetchCargoVendor {
                inherit src;
                inherit (src) pname version;
                hash = "sha256-qsO12332HSjWCVKtf1cUePWWb9IdYUmT+8OPj/XP2WE=";
                # hash = lib.fakeHash;
              };
            };
          }
        );
      in
      {
        checks = {
          # Build the crate as part of `nix flake check` for convenience
          inherit myServer myClient;

          # Run clippy (and deny all warnings) on the crate source,
          # again, reusing the dependency artifacts from above.
          #
          # Note that this is done as a separate derivation so that
          # we can block the CI if there are issues here, but not
          # prevent downstream consumers from building our crate by itself.
          my-app-clippy = craneLib.cargoClippy (
            commonArgs
            // {
              inherit cargoArtifacts;
              cargoClippyExtraArgs = "--all-targets -- --deny warnings";
              # Here we don't care about serving the frontend
              CLIENT_DIST = "";
            }
          );

          # Check formatting
          my-app-fmt = craneLib.cargoFmt commonArgs;
        };

        apps.default = flake-utils.lib.mkApp {
          name = "server";
          drv = myServer;
        };

        devShells.default = craneLib.devShell {
          # Inherit inputs from checks.
          checks = self.checks.${system};

          shellHook = ''
            export CLIENT_DIST=$PWD/client/dist;
          '';

          # Extra inputs can be added here; cargo and rustc are provided by default.
          packages = [
            pkgs.trunk
          ];
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>In addition to Unit and Integration tests, you can also write tests that
interact with your application as a real user would.
That technique is called End to End(E2E) testing.</p>
<p>In this example we have a workspace with two members:</p>
<ul>
<li>server: a web server that uses Axum for HTTP and Sqlx
connect to an instance of PostgreSQL</li>
<li>e2e: a end-to-end test "script" that drives
Firefox into interacting with the sever</li>
</ul>
<p>Quick-start an E2E project in a fresh directory with:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#end-to-end-testing
</code></pre>
<p>Alternatively, if you have an existing project already, copy and paste the
following <code>flake.nix</code> and modify it to build your workspace's packages:</p>
<pre><code class="language-nix">{
  description = "Example E2E testing";
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";

    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };
  outputs =
    {
      nixpkgs,
      crane,
      flake-utils,
      rust-overlay,
      ...
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = import nixpkgs {
          inherit system;
          overlays = [ (import rust-overlay) ];
        };
        inherit (pkgs) lib;

        craneLib = (crane.mkLib pkgs).overrideToolchain (p: p.rust-bin.stable.latest.default);
        src = craneLib.cleanCargoSource ./.;

        workspace = craneLib.buildPackage {
          inherit src;
          doCheck = false;
        };

        # The script inlined for brevity, consider extracting it
        # so that it becomes independent of nix
        runE2ETests =
          pkgs.runCommand "e2e-tests"
            {
              nativeBuildInputs = with pkgs; [
                retry
                curl
                geckodriver
                firefox
                cacert
                postgresql
              ];
            }
            ''

              wait-for-connection() {
                timeout 5s \
                  retry --until=success --delay "1" -- \
                    curl -s "$@"
              }

              initdb postgres-data
              pg_ctl --pgdata=postgres-data --options "-c unix_socket_directories=$PWD" start
              export DATABASE_URL="postgres:///postgres?host=$PWD"
              psql "$DATABASE_URL" &lt;&lt;EOF
                CREATE TABLE users(name TEXT);
              EOF

              ${workspace}/bin/server &amp;
              wait-for-connection --fail localhost:8000

              # Firefox likes to write to $HOME
              HOME="$(mktemp -d)" geckodriver &amp;
              wait-for-connection localhost:4444

              ${workspace}/bin/e2e_tests

              touch $out
            '';
      in
      {
        checks = {
          inherit workspace;
          # Firefox is broken in some platforms (namely "aarch64-apple-darwin"), skip those
        }
        // (lib.optionalAttrs (lib.meta.availableOn system pkgs.firefox) {
          inherit runE2ETests;
        });

        devShells.default = pkgs.mkShell {
          buildInputs =
            with pkgs;
            [
              rustc
              cargo
            ]
            ++ (lib.optionals (!pkgs.stdenv.isDarwin) [
              geckodriver
              firefox
            ]);
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>To build a cargo project which depends on the SQLx crate, run the following in a
fresh directory:</p>
<pre><code class="language-sh">nix flake init -t github:ipetkov/crane#sqlx
</code></pre>
<p>Alternatively, if you have an existing project already, copy and paste the
following <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  description = "Build a cargo project which uses SQLx";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs =
    {
      self,
      nixpkgs,
      crane,
      flake-utils,
      ...
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = nixpkgs.legacyPackages.${system};

        inherit (pkgs) lib;

        craneLib = crane.mkLib pkgs;

        unfilteredRoot = ./.; # The original, unfiltered source
        src = lib.fileset.toSource {
          root = unfilteredRoot;
          fileset = lib.fileset.unions [
            # Default files from crane (Rust and cargo files)
            (craneLib.fileset.commonCargoSources unfilteredRoot)
            # Include all the .sql migrations as well
            ./migrations
          ];
        };

        # Common arguments can be set here to avoid repeating them later
        commonArgs = {
          inherit src;
          strictDeps = true;

          nativeBuildInputs = [
            pkgs.pkg-config
          ];

          buildInputs = [
            # Add additional build inputs here
            pkgs.openssl
          ];

          # Additional environment variables can be set directly
          # MY_CUSTOM_VAR = "some value";
        };

        # Build *just* the cargo dependencies, so we can reuse
        # all of that work (e.g. via cachix) when running in CI
        cargoArtifacts = craneLib.buildDepsOnly commonArgs;

        # Build the actual crate itself, reusing the dependency
        # artifacts from above.
        my-crate = craneLib.buildPackage (
          commonArgs
          // {
            inherit cargoArtifacts;

            nativeBuildInputs = (commonArgs.nativeBuildInputs or [ ]) ++ [
              pkgs.sqlx-cli
            ];

            preBuild = ''
              export DATABASE_URL=sqlite:./db.sqlite3
              sqlx database create
              sqlx migrate run
            '';
          }
        );
      in
      {
        checks = {
          # Build the crate as part of `nix flake check` for convenience
          inherit my-crate;
        };

        packages = {
          default = my-crate;
          inherit my-crate;
        };

        devShells.default = craneLib.devShell {
          # Inherit inputs from checks.
          checks = self.checks.${system};

          # Additional dev-shell environment variables can be set directly
          # MY_CUSTOM_DEVELOPMENT_VAR = "something else";

          # Extra inputs can be added here; cargo and rustc are provided by default.
          packages = [
            pkgs.sqlx-cli
          ];
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="source-filtering"><a class="header" href="#source-filtering">Source filtering</a></h2>
<p>Nix considers that a derivation must be rebuilt whenever any of its inputs
change, including all source files passed into the build. Unfortunately, this
means that changes to any "irrelevant" files (such as the project README) would
end up rebuilding the project even if the final outputs don't actually care
about their contents!</p>
<p>Source filtering is a technique Nix employs that allows for better caching by
programmatically filtering out files which are known to not apply to the build
<em>before</em> the inputs are hashed.</p>
<p>A default source cleaner is available via <code>craneLib.cleanCargoSource</code>: it cleans
a source tree to omit things like version control directories as well omit any
non-Rust/non-cargo related files. It can be used like so:</p>
<pre><code class="language-nix">craneLib.buildPackage {
  # other attributes omitted
  src = craneLib.cleanCargoSource ./.;
}
</code></pre>
<p>It is possible to customize the filter to use when cleaning the source by
leveraging <code>craneLib.filterCargoSources</code>. By default this filter will only keep
files whose names end with <code>.rs</code> or <code>.toml</code>. Though it is possible to compose it
with other filters, especially if it is necessary to include additional files
which it might otherwise omit:</p>
<pre><code class="language-nix">let
  # Only keeps markdown files
  markdownFilter = path: _type: builtins.match ".*md$" path != null;
  markdownOrCargo = path: type:
    (markdownFilter path type) || (craneLib.filterCargoSources path type);
in
craneLib.buildPackage {
  # other attributes omitted
  src = lib.cleanSourceWith {
    src = ./.; # The original, unfiltered source
    filter = markdownOrCargo;
    name = "source"; # Be reproducible, regardless of the directory name
  };
}
</code></pre>
<h2 id="fileset-filtering"><a class="header" href="#fileset-filtering">Fileset filtering</a></h2>
<p>A more composable alternative to source filtering is using <a href="https://nixos.org/manual/nixpkgs/unstable/#sec-functions-library-fileset">filesets</a>:</p>
<pre><code class="language-nix">let
  unfilteredRoot = ./.; # The original, unfiltered source
  src = lib.fileset.toSource {
    root = unfilteredRoot;
    fileset = lib.fileset.unions [
      # Default files from crane (Rust and cargo files)
      (craneLib.fileset.commonCargoSources unfilteredRoot)
      # Also keep any markdown files
      (lib.fileset.fileFilter (file: file.hasExt "md") unfilteredRoot)
      # Example of a folder for images, icons, etc
      (lib.fileset.maybeMissing ./assets)
    ];
  };
in
craneLib.buildPackage {
  # other attributes omitted
  inherit src;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="local-development"><a class="header" href="#local-development">Local Development</a></h2>
<p><a href="https://nix.dev/tutorials/ad-hoc-developer-environments">Nix shells (or development
shells)</a> are extremely
powerful when it comes to locally developing with the exact same dependencies
used when building packages.</p>
<p>To get started, declare a default <code>devShell</code> in <code>flake.nix</code> using
<a href="API.html#cranelibdevshell"><code>craneLib.devShell</code></a> and run <code>nix develop</code> in the
project directory. Then, you can use something like
<a href="https://direnv.net"><code>direnv</code></a> or
<a href="https://github.com/nix-community/nix-direnv"><code>nix-direnv</code></a> to automatically
enter and exit a development shell when you enter or exit the project
directory!</p>
<p>Sample <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, crane, flake-utils, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
        craneLib = crane.mkLib pkgs;

        my-crate = craneLib.buildPackage {
          src = craneLib.cleanCargoSource ./.;

          buildInputs = [
            # Add additional build inputs here
          ] ++ pkgs.lib.optionals pkgs.stdenv.isDarwin [
            # Additional darwin specific inputs can be set here
            pkgs.libiconv
          ];

          # Additional environment variables can be set directly
          # MY_CUSTOM_VAR = "some value";
        };
      in
      {
        packages.default = my-crate;

        devShells.default = craneLib.devShell {
          # Additional dev-shell environment variables can be set directly
          MY_CUSTOM_DEV_URL = "http://localhost:3000";

          # Automatically inherit any build inputs from `my-crate`
          inputsFrom = [ my-crate ];

          # Extra inputs (only used for interactive development)
          # can be added here; cargo and rustc are provided by default.
          packages = [
            pkgs.cargo-audit
            pkgs.cargo-watch
          ];
        };
      });
}
</code></pre>
<p>Then, after integrating direnv into your shell:</p>
<pre><code class="language-sh">echo "use flake" &gt; .envrc
direnv allow
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="custom-cargo-commands"><a class="header" href="#custom-cargo-commands">Custom cargo commands</a></h2>
<p>Although it is possible to customize exactly what build commands and flags are
used by the provided functions like <code>buildPackage</code>, or <code>cargoBuild</code>, sometimes
it is useful to encapsulate a cargo invocation that crane does not know about.
Doing so allows that helper function to be used across different crates, or even
different Nix flakes without having to duplicate the logic in multiple build
definitions.</p>
<p><code>mkCargoDerivation</code> allows building such extensions. Below is a short example to
illustrate the approach. The <a href="./API.html#libmkcargoderivation">reference</a> also
explores the inputs and behavior of <code>mkCargoDerivation</code> in greater depth.</p>
<pre><code class="language-nix">{ pkgs, craneLib }:

# Let's assume we want to add a helper for a fictitious `cargo awesome` command
let
  cargoAwesome = {
    cargoArtifacts,
    cargoAwesomeExtraArgs ? "", # Arguments that are generally useful default
    cargoExtraArgs ? "" # Other cargo-general flags (e.g. for features or targets)
  }@origArgs: let
    # Clean the original arguments for good hygiene (i.e. so the flags specific
    # to this helper don't pollute the environment variables of the derivation)
    args = builtins.removeAttrs origArgs [
      "cargoAwesomeExtraArgs"
      "cargoExtraArgs"
    ];
  in
  craneLib.mkCargoDerivation (args // {
    # Additional overrides we want to explicitly set in this helper

    # Require the caller to specify cargoArtifacts we can use
    inherit cargoArtifacts;

    # A suffix name used by the derivation, useful for logging
    pnameSuffix = "-awesome";

    # Set the cargo command we will use and pass through the flags
    buildPhaseCargoCommand = "cargo awesome ${cargoExtraArgs} ${cargoAwesomeExtraArgs}";

    # Append the `cargo-awesome` package to the nativeBuildInputs set by the
    # caller (or default to an empty list if none were set)
    nativeBuildInputs = (args.nativeBuildInputs or [ ]) ++ [ pkgs.cargo-awesome ];
  });
in
cargoAwesome {
  src = craneLib.cleanCargoSource ./.;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="customizing-builds"><a class="header" href="#customizing-builds">Customizing builds</a></h2>
<p>All derivations, whether they are configured through <code>buildPackage</code>,
<code>cargoBuild</code>, or even <code>mkCargoDerivation</code>, eventually delegate to
<a href="https://nixos.org/manual/nixpkgs/unstable/#ssec-stdenv-dependencies"><code>mkDerivation</code> which is defined by
nixpkgs</a>.</p>
<p>At its heart, <code>mkDerivation</code> builds up a big <code>bash</code> script which is executed by
the builder. Inputs are added to the execution <code>$PATH</code>, libraries are added to
include paths, and all other variables are set as shell variables. But these
scripts also come with a small framework for <a href="https://nixos.org/manual/nixpkgs/unstable/#sec-stdenv-phases">running various different
phases</a>. Many of
these phases also come with their own <em>hooks</em> which are shell functions which
can be subscribed to execute before and/or after a particular phase has run.</p>
<p>Although build phases and their hooks allow for easily extending and customizing
the build instructions for a particular derivation, it can become difficult to
identify exactly where a bit of logic should execute. The following are a good
set of resources to consult when in doubt:</p>
<ol>
<li>The <a href="https://nixos.org/manual/nixpkgs/unstable/#sec-stdenv-phases">nixpkgs
manual</a> for
describing the default set of build phases and their hooks</li>
<li>The <a href="./API.html">crane API reference</a> for additional hooks it introduces</li>
<li>Setting <code>NIX_DEBUG</code> to a non-zero value will cause the builder to print out
various variables and commands it will run (increasing values will increase
the verbosity).</li>
<li>When all else fails <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/setup.sh">source for the generic build
scripts</a>
themselves can be useful</li>
</ol>
<p>All that out of the way, here's a quick example of how to use the build phases
and hooks to customize a particular build:</p>
<pre><code class="language-nix">craneLib.buildPackage {
  src = craneLib.cleanCargoSource ./.;

  # Define a list of function names to execute before the `configurePhase` runs
  preConfigurePhases = [
    "foo"
    "bar"
  ];

  # Define the functions themselves
  foo = ''
    # double the amount of rust test threads we can use
    # Note that crane will set these defaults as a `postPatchHook` which
    # should have already run by the time the preConfigurePhases are called
    export RUST_TEST_THREADS=$((RUST_TEST_THREADS * 2))
  '';

  bar = ''
    # decrement by one test thread if running in release mode
    if [[ "${CARGO_PROFILE}" == "release" ]]; then
      export RUST_TEST_THREADS=$((RUST_TEST_THREADS - 2))
    fi
  '';

  # Lastly, add postInstall to install additional items after
  # the default installPhase has run and installed the package binaries
  postInstall = ''
    echo "hello world" &gt; $out/hello.txt
    # also install the README.md for good measure
    cp README.md $out/
  '';
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="overriding-derivations"><a class="header" href="#overriding-derivations">Overriding derivations</a></h2>
<p>Sometimes it is useful for a downstream consumer of a derivation to override
portions of its behavior (such as swapping out a dependency with another
customized package, or to perhaps opt-in or opt-out of additional behavior).
There are two main techniques to achieve this defined by <code>nixpkgs</code>: using
<code>.override</code> and <code>.overrideAttrs</code>.</p>
<p>Neither of these are specific to <code>crane</code>, but are documented here as a general
primer.</p>
<h3 id="override"><a class="header" href="#override"><code>.override</code></a></h3>
<p>The <code>.override</code> attribute comes from <code>makeOverridable</code> from <code>nixpkgs</code>, which is
automatically invoked by <code>callPackage</code>. Normally using <code>.override</code> only changes
the parameters made available to the function which prepares the derivation, <em>but
does not alter the derivation's attributes</em> directly:</p>
<pre><code class="language-nix"># my-crate.nix
{ craneLib
, lib
, withFoo ? true
, withBar ? false
}:

craneLib.buildPackage {
  src = craneLib.cleanCargoSource ./..;
  strictDeps = true;
  cargoExtraArgs =
      (lib.optionalString withFoo "--features foo") +
      (lib.optionalString withBar "--features bar");
}
</code></pre>
<pre><code class="language-nix"># flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";

    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs = { self, nixpkgs, crane, flake-utils, rust-overlay, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = import nixpkgs {
          inherit system;
          overlays = [ (import rust-overlay) ];
        };

        craneLib = crane.mkLib pkgs;
        my-crate = pkgs.callPackage ./my-crate.nix {
          inherit craneLib;
        };
      in
      {
        packages = {
          # The default definition
          default = my-crate;

          # Ensure all additional options are enabled
          my-crate-all = my-crate.override {
            withBar = true;
          };

          # Disable all optional functionality
          my-crate-minimal = my-crate.override {
            withFoo = false;
          };

          # Use a different `craneLib` instantiation: one with a nightly compiler
          my-crate-nightly = my-crate.override {
            craneLib = craneLib.overrideToolchain (p: p.rust-bin.nightly.latest.default);
          };
        };
      });
}
</code></pre>
<h3 id="overrideattrs"><a class="header" href="#overrideattrs"><code>.overrideAttrs</code></a></h3>
<p>The <code>.overrideAttrs</code> attribute comes from <code>mkDerivation</code> (which all <code>crane</code> APIs
eventually call) and it allows changing what is passed into <code>mkDerivation</code>
itself (i.e. this <em>does</em> change derivation attributes). It is a much more low
level operation, and although it <em>can</em> be used to achieve the same things
possible via <code>.override</code>, it may be more cumbersome to plumb the changes
through.</p>
<p>Note that <code>.overrideAttrs</code> <em>will</em> <em><strong>not</strong></em> change what inputs <code>crane</code> APIs see,
as it affects the derivation produced <em>after</em> those APIs have finished running.
If you need to change behavior that way, consider using a combination of
<code>callPackage</code> and <code>.override</code>.</p>
<pre><code class="language-nix"># flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    crane.url = "github:ipetkov/crane";

    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, crane, flake-utils, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};

        craneLib = crane.mkLib pkgs;
        my-crate = craneLib.buildPackage {
          src = craneLib.cleanCargoSource ./.;
          strictDeps = true;
        };
      in
      {
        packages = {
          # The default definition
          default = my-crate;

          # Perform a build with debug logging enabled
          my-crate-debug = my-crate.overrideAttrs (old: {
            NIX_DEBUG = 10;
          });
        };
      });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="patching-sources-of-dependency-crates"><a class="header" href="#patching-sources-of-dependency-crates">Patching sources of dependency crates</a></h2>
<p>Sometimes it is useful to patch the sources of dependency crates without needing
to wait for an upstream release to include a necessary change, or without
needing to use a custom git fork.</p>
<p>The <code>vendorCargoDeps</code>, <code>vendorCargoRegistries</code>, <code>vendorGitDeps</code>, and
<code>vendorMultipleCargoDeps</code> APIs support arbitrary overrides (i.e. patching) at
the individual crate/repo level when vendoring sources. Checkout their
respective API documentation for more details, but below is a short quick start
example:</p>
<pre><code class="language-nix">let
  baseArgs = {
    src = craneLib.cleanCargoSource ./.;
  };

  isNumCpusRepo = p: lib.hasPrefix
      "git+https://github.com/seanmonstar/num_cpus.git"
      p.source;
  isTag1_13_1 = p: lib.hasInfix
      "tag=v1.13.1"
      p.source;

  cargoVendorDir = craneLib.vendorCargoDeps (baseArgs // {
    # Use this function to override crates coming from git dependencies
    overrideVendorGitCheckout = ps: drv:
      # For example, patch a specific repository and tag, in this case num_cpus-1.13.1
      if lib.any (p: (isNumCpusRepo p) &amp;&amp; (isTag1_13_1 p)) ps then
        drv.overrideAttrs (_old: {
          # Specifying an arbitrary patch to apply
          patches = [
            ./0001-patch-num-cpus.patch
          ];

          # Similarly we can also run additional hooks to make changes
          postPatch = ''
            echo running some arbitrary command to make modifications
          '';
        })
      else
        # Nothing to change, leave the derivations as is
        drv;

    # Use this function to override crates coming from any registry checkout
    overrideVendorCargoPackage = p: drv:
      # For example, patch a specific crate, in this case byteorder-1.5.0
      if p.name == "byteorder" &amp;&amp; p.version == "1.5.0" then
        drv.overrideAttrs (_old: {
          # Specifying an arbitrary patch to apply
          patches = [
            ./0001-patch-byteorder.patch
          ];

          # Similarly we can also run additional hooks to make changes
          postPatch = ''
            echo running some arbitrary command to make modifications
          '';
        })
      else
        # Nothing to change, leave the derivations as is
        drv;
  });

  commonArgs = baseArgs // {
    inherit cargoVendorDir;
  };
in
craneLib.buildPackage commonArgs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h1>
<h2 id="mklib"><a class="header" href="#mklib"><code>mkLib</code></a></h2>
<p><code>mkLib :: pkgs -&gt; set</code></p>
<p>Creates a <code>lib</code> instance bound to the specified (and instantiated) <code>pkgs</code> set.
This is a convenience escape hatch in case you want to use your own custom
instantiation of nixpkgs with the overlays you may need.</p>
<pre><code class="language-nix">mkLib (import inputs.nixpkgs { system = "armv7l-linux"; })
</code></pre>
<p>Note that if you wish to override a particular package without having to overlay
it across all of nixpkgs, consider using <code>overrideScope</code>:</p>
<pre><code class="language-nix">(mkLib pkgs).overrideScope (final: prev: {
  cargo-tarpaulin = myCustomCargoTarpaulinVersion;
})
</code></pre>
<p>To overlay an entire rust toolchain (e.g. <code>cargo</code>, <code>rustc</code>, <code>clippy</code>, <code>rustfmt</code>,
etc.) consider using <code>overrideToolchain</code>.</p>
<h2 id="cranelib"><a class="header" href="#cranelib"><code>craneLib</code></a></h2>
<p><code>craneLib</code> represents an instantiated value crated by <code>mkLib</code> above.</p>
<h3 id="cranelibappendcrateregistries"><a class="header" href="#cranelibappendcrateregistries"><code>craneLib.appendCrateRegistries</code></a></h3>
<p><code>appendCrateRegistries :: [registry mapping] -&gt; new lib</code></p>
<p>Creates a new <code>lib</code> instance which will make additional registries available for
use when downloading crate sources. Each entry can be defined using:</p>
<ul>
<li><code>registryFromDownloadUrl</code>: if you know the exact <code>dl</code> URL as defined in the
registry's <code>config.json</code> file</li>
<li><code>registryFromGitIndex</code>: if you would like the download URL to be inferred from
the index's source directly.</li>
<li><code>registryFromSparse</code>: if you would like the download URL to be inferred from
the index's source directly, and the index is a sparse index.</li>
</ul>
<p>See the documentation on each function for more specifics.</p>
<pre><code class="language-nix">newLib = craneLib.appendCrateRegistries [
  (craneLib.registryFromDownloadUrl {
    indexUrl = "https://github.com/rust-lang/crates.io-index";
    dl = "https://static.crates.io/crates";
    fetchurlExtraArgs = {};
  })

  # Or, alternatively
  (craneLib.registryFromGitIndex {
    indexUrl = "https://github.com/Hirevo/alexandrie-index";
    rev = "90df25daf291d402d1ded8c32c23d5e1498c6725";
    fetchurlExtraArgs = {};
  })

  # Or even
  (lib.registryFromSparse {
    indexUrl = "https://index.crates.io/config.json";
    configSha256 = "1cxgzdm1ipqmgwnq7kgym92axna7pfyhgfla63vl7dvydwn3m52v";
    fetchurlExtraArgs = {};
  })
];
</code></pre>
<h3 id="cranelibbuilddepsonly"><a class="header" href="#cranelibbuilddepsonly"><code>craneLib.buildDepsOnly</code></a></h3>
<p><code>buildDepsOnly :: set -&gt; drv</code></p>
<p>Create a derivation which will only build all dependencies of a cargo workspace.</p>
<p>Useful for splitting up cargo projects into two derivations: one which only
builds dependencies and needs to be rebuilt when a Cargo.lock file changes, and
another which inherits the cargo artifacts from the first and (quickly) builds
just the application itself.</p>
<p>The exact cargo commands being run (or the arguments passed into it) can be
easily updated to suit your needs. By default all artifacts from running <code>cargo {check,build,test}</code> will be cached.</p>
<p>In addition to all default and overridden values being set as documented below,
all derivation attributes are delegated to <code>mkCargoDerivation</code>, and can be used
to influence its behavior.</p>
<ul>
<li><code>cargoArtifacts</code>: set to <code>null</code> since this is our entry point for generating
cargo artifacts</li>
<li><code>doInstallCargoArtifacts</code>: set to <code>true</code></li>
<li><code>pnameSuffix</code>: set to <code>"-deps"</code></li>
<li><code>src</code>: set to the result of <code>mkDummySrc</code> after applying the arguments set.
This ensures that we do not need to rebuild the cargo artifacts derivation
whenever the application source changes.</li>
<li><code>CRANE_BUILD_DEPS_ONLY</code> is exported as an environment variable, in case this
is handy for scripts or hooks which may want to customize how they run</li>
</ul>
<h4 id="optional-attributes"><a class="header" href="#optional-attributes">Optional attributes</a></h4>
<ul>
<li><code>buildPhaseCargoCommand</code>: A command to run during the derivation's build
phase. Pre and post build hooks will automatically be run.
<ul>
<li>Default value: <code>"${cargoCheckCommand} ${cargoExtraArgs}\n${cargoBuildCommand} ${cargoExtraArgs}"</code></li>
</ul>
</li>
<li><code>cargoBuildCommand</code>: A cargo (build) invocation to run during the derivation's build
phase
<ul>
<li>Default value: <code>"cargo build --profile release"</code>
<ul>
<li><code>CARGO_PROFILE</code> can be set on the derivation to alter which cargo profile
is selected; setting it to <code>""</code> will omit specifying a profile
altogether.</li>
</ul>
</li>
</ul>
</li>
<li><code>cargoCheckCommand</code>: A cargo (check) invocation to run during the derivation's build
phase (in order to cache additional artifacts)
<ul>
<li>Default value: <code>"cargo check --profile release ${cargoCheckExtraArgs}"</code>
<ul>
<li><code>CARGO_PROFILE</code> can be set on the derivation to alter which cargo profile
is selected; setting it to <code>""</code> will omit specifying a profile
altogether.</li>
</ul>
</li>
</ul>
</li>
<li><code>cargoCheckExtraArgs</code>: additional flags to be passed in the <code>cargoCheckCommand</code>
invocation
<ul>
<li>Default value: <code>"--all-targets"</code> if <code>doCheck</code> is set to true, <code>""</code> otherwise</li>
</ul>
</li>
<li><code>cargoExtraArgs</code>: additional flags to be passed in the cargo invocation (e.g.
enabling specific features)
<ul>
<li>Default value: <code>"--locked"</code></li>
</ul>
</li>
<li><code>cargoTestCommand</code>: A cargo invocation to run during the derivation's check
phase
<ul>
<li>Default value: <code>"cargo test --profile release"</code>
<ul>
<li><code>CARGO_PROFILE</code> can be set on the derivation to alter which cargo profile
is selected; setting it to <code>""</code> will omit specifying a profile
altogether.</li>
</ul>
</li>
</ul>
</li>
<li><code>cargoTestExtraArgs</code>: additional flags to be passed in the <code>cargoTestCommand</code>
invocation (e.g. enabling specific tests)
<ul>
<li>Default value: <code>"--no-run"</code></li>
</ul>
</li>
<li><code>cargoVendorDir</code>: A path (or derivation) of vendored cargo sources which can
be consumed without network access. Directory structure should basically
follow the output of <code>cargo vendor</code>.
<ul>
<li>Default value: the result of <code>vendorCargoDeps</code> after applying the arguments
set (with the respective default values). Note if <code>dummySrc</code> is specified,
it will be used as the <code>src</code> passed into <code>vendorCargoDeps</code></li>
</ul>
</li>
<li><code>checkPhaseCargoCommand</code>: A command to run during the derivation's check
phase. Pre and post check hooks will automatically be run.
<ul>
<li>Default value: <code>"${cargoTestCommand} ${cargoExtraArgs}"</code></li>
</ul>
</li>
<li><code>doCheck</code>: whether the derivation's check phase should be run
<ul>
<li>Default value: <code>true</code></li>
</ul>
</li>
<li><code>dummySrc</code>: the "dummy" source to use when building this derivation.
Automatically derived if not passed in
<ul>
<li>Default value: <code>mkDummySrc args.src</code></li>
</ul>
</li>
<li><code>pname</code>: package name of the derivation
<ul>
<li>Default value: inherited from calling <code>crateNameFromCargoToml</code>. Note if
<code>dummySrc</code> is specified, it will be used as the <code>src</code> passed into
<code>crateNameFromCargoToml</code></li>
</ul>
</li>
<li><code>version</code>: version of the derivation
<ul>
<li>Default value: inherited from calling <code>crateNameFromCargoToml</code>. Note if
<code>dummySrc</code> is specified, it will be used as the <code>src</code> passed into
<code>crateNameFromCargoToml</code></li>
</ul>
</li>
</ul>
<h4 id="remove-attributes"><a class="header" href="#remove-attributes">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoBuildCommand</code></li>
<li><code>cargoCheckCommand</code></li>
<li><code>cargoCheckExtraArgs</code></li>
<li><code>cargoExtraArgs</code></li>
<li><code>cargoTestCommand</code></li>
<li><code>cargoTestExtraArgs</code></li>
<li><code>dummySrc</code></li>
<li><code>outputHashes</code></li>
<li><code>outputs</code></li>
</ul>
<h3 id="cranelibbuildpackage"><a class="header" href="#cranelibbuildpackage"><code>craneLib.buildPackage</code></a></h3>
<p><code>buildPackage :: set -&gt; drv</code></p>
<p>A(n opinionated) version of <code>mkCargoDerivation</code> which will install to the output
any binaries which were built by cargo in this invocation. All options
understood by <code>mkCargoDerivation</code> apply here as well, with the only difference
being some additional book keeping necessary to log cargo's results and
subsequently install from that log.</p>
<p>Note that only <code>bin</code>, <code>cdylib</code>, <code>dylib</code>, and <code>staticlib</code>, targets will be installed by
default (namely <code>rlib</code> targets will be ignored), though it is possible to adjust
the behavior by changing the <code>installPhaseCommand</code> or registering additional
install hooks.</p>
<h4 id="optional-attributes-1"><a class="header" href="#optional-attributes-1">Optional attributes</a></h4>
<ul>
<li><code>buildPhaseCargoCommand</code>: A command to run during the derivation's build
phase. Pre and post build hooks will automatically be run.
<ul>
<li>Default value: <code>cargoBuildCommand</code> will be invoked along with
<code>cargoExtraArgs</code> passed in, except cargo's build steps will also be captured
and written to a log so that it can be used to find the build binaries.</li>
<li>Note that the default install hook assumes that the build phase will create
a log of cargo's build results. If you wish to customize this command
completely, make sure that cargo is run with <code>--message-format json-render-diagnostics</code> and the standard output captured and saved to a
file. The <code>cargoBuildLog</code> shell variable should point to this log.</li>
</ul>
</li>
<li><code>cargoArtifacts</code>: A path (or derivation) which contains an existing cargo
<code>target</code> directory, which will be reused at the start of the derivation.
Useful for caching incremental cargo builds.
<ul>
<li>Default value: the result of <code>buildDepsOnly</code> after applying the arguments
set (with the respective default values).</li>
<li><code>installPhase</code> and <code>installPhaseCommand</code> will be removed, and no
installation hooks will be run</li>
</ul>
</li>
<li><code>cargoBuildCommand</code>: A cargo invocation to run during the derivation's build
phase
<ul>
<li>Default value: <code>"cargo build --profile release"</code>
<ul>
<li><code>CARGO_PROFILE</code> can be set on the derivation to alter which cargo profile
is selected; setting it to <code>""</code> will omit specifying a profile
altogether.</li>
</ul>
</li>
</ul>
</li>
<li><code>cargoExtraArgs</code>: additional flags to be passed in the cargo invocation (e.g.
enabling specific features)
<ul>
<li>Default value: <code>"--locked"</code></li>
</ul>
</li>
<li><code>cargoTestCommand</code>: A cargo invocation to run during the derivation's check
phase
<ul>
<li>Default value: <code>"cargo test --profile release"</code>
<ul>
<li><code>CARGO_PROFILE</code> can be set on the derivation to alter which cargo profile
is selected; setting it to <code>""</code> will omit specifying a profile
altogether.</li>
</ul>
</li>
</ul>
</li>
<li><code>cargoTestExtraArgs</code>: additional flags to be passed in the <code>cargoTestCommand</code>
invocation (e.g. enabling specific tests)
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
<li><code>doCheck</code>: whether the derivation's check phase should be run
<ul>
<li>Default value: <code>true</code></li>
</ul>
</li>
<li><code>doInstallCargoArtifacts</code>: controls whether cargo's <code>target</code> directory should
be copied as an output
<ul>
<li>Default value: <code>false</code></li>
</ul>
</li>
<li><code>installPhaseCommand</code>: the command(s) which are expected to install the
derivation's outputs.
<ul>
<li>Default value: will look for a temporary installation directory created by
<code>installFromCargoBuildLogHook</code> and then install all of its contents</li>
</ul>
</li>
</ul>
<h4 id="remove-attributes-1"><a class="header" href="#remove-attributes-1">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoBuildCommand</code></li>
<li><code>cargoExtraArgs</code></li>
<li><code>cargoTestCommand</code></li>
<li><code>cargoTestExtraArgs</code></li>
<li><code>outputHashes</code></li>
</ul>
<h4 id="native-build-dependencies-and-included-hooks"><a class="header" href="#native-build-dependencies-and-included-hooks">Native build dependencies and included hooks</a></h4>
<p>The following hooks are automatically added as native build inputs:</p>
<ul>
<li><code>installFromCargoBuildLogHook</code></li>
<li><code>removeReferencesToRustToolchainHook</code></li>
<li><code>removeReferencesToVendoredSourcesHook</code></li>
</ul>
<h3 id="cranelibbuildtrunkpackage"><a class="header" href="#cranelibbuildtrunkpackage"><code>craneLib.buildTrunkPackage</code></a></h3>
<p><code>buildTrunkPackage :: set -&gt; drv</code></p>
<p>Create a derivation which will build a distributable directory for a WASM application.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<h4 id="optional-attributes-2"><a class="header" href="#optional-attributes-2">Optional attributes</a></h4>
<ul>
<li><code>buildPhaseCargoCommand</code>: A command to run during the derivation's build
phase. Pre and post build hooks will automatically be run.
<ul>
<li>Default value: <code>trunk build</code> will be invoked along with <code>trunkExtraArgs</code>,
<code>trunkExtraBuildArgs</code>, and <code>trunkIndexpath</code> passed in. If <code>$CARGO_PROFILE</code>
is set to <code>release</code> then the <code>--release</code> flag will also be set for the build</li>
</ul>
</li>
<li><code>cargoArtifacts</code>: A path (or derivation) which contains an existing cargo
<code>target</code> directory, which will be reused at the start of the derivation.
Useful for caching incremental cargo builds.
<ul>
<li>Default value: the result of <code>buildDepsOnly</code> after applying the arguments
set (with the respective default values).</li>
<li><code>CARGO_BUILD_TARGET</code> will be set to <code>"wasm32-unknown-unknown"</code> if not specified.</li>
<li><code>doCheck</code> will be set to <code>false</code> if not specified.</li>
<li><code>installPhase</code> and <code>installPhaseCommand</code> will be removed (in favor of their
default values provided by <code>buildDepsOnly</code>)</li>
</ul>
</li>
<li><code>installPhaseCommand</code>: the command(s) which are expected to install the
derivation's outputs.
<ul>
<li>Default value: will install trunk's <code>dist</code> output directory</li>
</ul>
</li>
<li><code>trunkExtraArgs</code> pass additional arguments to <code>trunk</code>
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
<li><code>trunkExtraBuildArgs</code> pass additional arguments to <code>trunk build</code>
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
<li><code>trunkIndexPath</code> A path to the index.html of your trunk project
<ul>
<li>Default value: <code>"./index.html"</code></li>
</ul>
</li>
<li><code>wasm-bindgen-cli</code> The package used to satisfy the <code>wasm-bindgen-cli</code>
dependency of <code>trunk</code>, the version used here must match the version
of <code>wasm-bindgen</code> in the <code>Cargo.lock</code> file of your project <em>exactly</em>.
<ul>
<li>Default value: <code>pkgs.wasm-bindgen-cli</code></li>
</ul>
</li>
</ul>
<h4 id="remove-attributes-2"><a class="header" href="#remove-attributes-2">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>trunkExtraArgs</code></li>
<li><code>trunkExtraBuildArgs</code></li>
<li><code>trunkIndexPath</code></li>
</ul>
<h4 id="native-build-dependencies-and-included-hooks-1"><a class="header" href="#native-build-dependencies-and-included-hooks-1">Native build dependencies and included hooks</a></h4>
<p>The following hooks are automatically added as native build inputs:</p>
<ul>
<li><code>binaryen</code></li>
<li><code>dart-sass</code></li>
<li><code>trunk</code></li>
<li><code>removeReferencesToRustToolchainHook</code></li>
<li><code>removeReferencesToVendoredSourcesHook</code></li>
</ul>
<h3 id="cranelibcargoaudit"><a class="header" href="#cranelibcargoaudit"><code>craneLib.cargoAudit</code></a></h3>
<p><code>cargoAudit :: set -&gt; drv</code></p>
<p>Create a derivation which will run a <code>cargo audit</code> invocation in a cargo
workspace.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<ul>
<li><code>buildPhaseCargoCommand</code> will be set to run <code>cargo audit -n -d ${advisory-db}</code> in
the workspace.</li>
<li><code>cargoArtifacts</code> will be set to <code>null</code> as they are not needed</li>
<li><code>cargoVendorDir</code> will be set to <code>null</code> as it is not needed</li>
<li><code>doInstallCargoArtifacts</code> is disabled</li>
<li><code>pnameSuffix</code> will be set to <code>"-audit"</code></li>
<li><code>src</code> will be filtered to only keep <code>Cargo.lock</code> files</li>
</ul>
<h4 id="required-attributes"><a class="header" href="#required-attributes">Required attributes</a></h4>
<ul>
<li><code>advisory-db</code>: A path (or derivation) which contains the advisory database
<ul>
<li>It is possible to track the advisory database as a flake input and avoid
having to manually update hashes or specific revisions to check out</li>
</ul>
</li>
<li><code>src</code>: The project source to audit, it must contain a <code>Cargo.lock</code> file
<ul>
<li>Note that the source will internally be filtered to omit any files besides
<code>Cargo.lock</code>. This avoids having to audit the project again until either the
advisory database or the dependencies change.</li>
</ul>
</li>
</ul>
<h4 id="optional-attributes-3"><a class="header" href="#optional-attributes-3">Optional attributes</a></h4>
<ul>
<li><code>cargoAuditExtraArgs</code>: additional flags to be passed in the cargo-audit invocation
<ul>
<li>Default value: <code>"--ignore yanked"</code></li>
</ul>
</li>
<li><code>pname</code>: the name of the derivation; will <em>not</em> be introspected from a
<code>Cargo.toml</code> file
<ul>
<li>Default value: <code>"crate"</code></li>
</ul>
</li>
<li><code>version</code>: the version of the derivation, will <em>not</em> be introspected from a
<code>Cargo.toml</code> file
<ul>
<li>Default value: <code>"0.0.0"</code></li>
</ul>
</li>
</ul>
<h4 id="native-build-dependencies"><a class="header" href="#native-build-dependencies">Native build dependencies</a></h4>
<p>The <code>cargo-audit</code> package is automatically appended as a native build input to any
other <code>nativeBuildInputs</code> specified by the caller.</p>
<h4 id="remove-attributes-3"><a class="header" href="#remove-attributes-3">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoAuditExtraArgs</code></li>
</ul>
<h3 id="cranelibcargodeny"><a class="header" href="#cranelibcargodeny"><code>craneLib.cargoDeny</code></a></h3>
<p><code>cargoDeny :: set -&gt; drv</code></p>
<p>Create a derivation which will run a <code>cargo deny</code> invocation in a cargo
workspace.</p>
<p>Note that although <code>cargo deny</code> can serve as a replacement for <code>cargo audit</code>,
<code>craneLib.cargoDeny</code> does not expose this functionality because <code>cargo deny</code>
requires the full source tree, rather than working from just the <code>Cargo.lock</code>
file, meaning it will be re-run when any source file changes, rather than only
when dependencies change.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<ul>
<li><code>buildPhaseCargoCommand</code> will be set to run
<code>cargo --offline $cargoExtraArgs deny $cargoDenyExtraArgs check $cargoDenyChecks</code> in the workspace.</li>
<li><code>cargoArtifacts</code> will be set to <code>null</code></li>
<li><code>doInstallCargoArtifacts</code> will be set to <code>false</code></li>
<li><code>pnameSuffix</code> will be set to <code>"-deny"</code></li>
</ul>
<h4 id="optional-attributes-4"><a class="header" href="#optional-attributes-4">Optional attributes</a></h4>
<ul>
<li><code>cargoDenyChecks</code>: check types to run
<ul>
<li>Default value: <code>"bans licenses sources"</code></li>
</ul>
</li>
<li><code>cargoDenyExtraArgs</code>: additional flags to be passed in the cargo-deny invocation
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
<li><code>cargoExtraArgs</code>: additional flags to be passed in the cargo invocation
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
</ul>
<h4 id="native-build-dependencies-1"><a class="header" href="#native-build-dependencies-1">Native build dependencies</a></h4>
<p>The <code>cargo-deny</code> package is automatically appended as a native build input to any
other <code>nativeBuildInputs</code> specified by the caller.</p>
<h4 id="remove-attributes-4"><a class="header" href="#remove-attributes-4">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoDenyExtraArgs</code></li>
<li><code>cargoExtraArgs</code></li>
</ul>
<h3 id="cranelibcargobuild"><a class="header" href="#cranelibcargobuild"><code>craneLib.cargoBuild</code></a></h3>
<p><code>cargoBuild :: set -&gt; drv</code></p>
<p>Create a derivation which will run a <code>cargo build</code> invocation in a cargo
workspace. Consider using <code>buildPackage</code> if all you need is to build the
workspace and install the resulting application binaries.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<ul>
<li><code>buildPhaseCargoCommand</code> will be set to run <code>cargo build --profile release</code> for
the workspace.
<ul>
<li><code>CARGO_PROFILE</code> can be set on the derivation to alter which cargo profile
is selected; setting it to <code>""</code> will omit specifying a profile
altogether.</li>
</ul>
</li>
<li><code>pnameSuffix</code> will be set to <code>"-build"</code></li>
</ul>
<h4 id="required-attributes-1"><a class="header" href="#required-attributes-1">Required attributes</a></h4>
<ul>
<li><code>cargoArtifacts</code>: A path (or derivation) which contains an existing cargo
<code>target</code> directory, which will be reused at the start of the derivation.
Useful for caching incremental cargo builds.
<ul>
<li>This can be prepared via <code>buildDepsOnly</code></li>
<li>Alternatively, any cargo-based derivation which was built with
<code>doInstallCargoArtifacts = true</code> will work as well</li>
</ul>
</li>
</ul>
<h4 id="optional-attributes-5"><a class="header" href="#optional-attributes-5">Optional attributes</a></h4>
<ul>
<li><code>cargoExtraArgs</code>: additional flags to be passed in the cargo invocation (e.g.
enabling specific features)
<ul>
<li>Default value: <code>"--locked"</code></li>
</ul>
</li>
</ul>
<h4 id="remove-attributes-5"><a class="header" href="#remove-attributes-5">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoExtraArgs</code></li>
</ul>
<h3 id="cranelibcargoclippy"><a class="header" href="#cranelibcargoclippy"><code>craneLib.cargoClippy</code></a></h3>
<p><code>cargoClippy :: set -&gt; drv</code></p>
<p>Create a derivation which will run a <code>cargo clippy</code> invocation in a cargo
workspace.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<ul>
<li><code>buildPhaseCargoCommand</code> will be set to run <code>cargo clippy --profile release</code> for
the workspace.
<ul>
<li><code>CARGO_PROFILE</code> can be set on the derivation to alter which cargo profile
is selected; setting it to <code>""</code> will omit specifying a profile
altogether.</li>
</ul>
</li>
<li><code>pnameSuffix</code> will be set to <code>"-clippy"</code></li>
</ul>
<h4 id="required-attributes-2"><a class="header" href="#required-attributes-2">Required attributes</a></h4>
<ul>
<li><code>cargoArtifacts</code>: A path (or derivation) which contains an existing cargo
<code>target</code> directory, which will be reused at the start of the derivation.
Useful for caching incremental cargo builds.
<ul>
<li>This can be prepared via <code>buildDepsOnly</code></li>
<li>Alternatively, any cargo-based derivation which was built with
<code>doInstallCargoArtifacts = true</code> will work as well</li>
</ul>
</li>
</ul>
<h4 id="optional-attributes-6"><a class="header" href="#optional-attributes-6">Optional attributes</a></h4>
<ul>
<li><code>cargoClippyExtraArgs</code>: additional flags to be passed in the clippy invocation (e.g.
deny specific lints)
<ul>
<li>Default value: <code>"--all-targets"</code></li>
</ul>
</li>
<li><code>cargoExtraArgs</code>: additional flags to be passed in the cargo invocation (e.g.
enabling specific features)
<ul>
<li>Default value: <code>"--locked"</code></li>
</ul>
</li>
</ul>
<h4 id="native-build-dependencies-2"><a class="header" href="#native-build-dependencies-2">Native build dependencies</a></h4>
<p>The <code>clippy</code> package is automatically appended as a native build input to any
other <code>nativeBuildInputs</code> specified by the caller.</p>
<h4 id="remove-attributes-6"><a class="header" href="#remove-attributes-6">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoClippyExtraArgs</code></li>
<li><code>cargoExtraArgs</code></li>
</ul>
<h3 id="cranelibcargodoc"><a class="header" href="#cranelibcargodoc"><code>craneLib.cargoDoc</code></a></h3>
<p><code>cargoDoc :: set -&gt; drv</code></p>
<p>Create a derivation which will run a <code>cargo doc</code> invocation in a cargo
workspace.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<ul>
<li><code>buildPhaseCargoCommand</code> will be set to run <code>cargo doc --profile release</code> for
the workspace.
<ul>
<li><code>CARGO_PROFILE</code> can be set on the derivation to alter which cargo profile
is selected; setting it to <code>""</code> will omit specifying a profile
altogether.</li>
</ul>
</li>
<li><code>doInstallCargoArtifacts</code> will default to <code>false</code> if not specified</li>
<li><code>pnameSuffix</code> will be set to <code>"-doc"</code></li>
</ul>
<h4 id="required-attributes-3"><a class="header" href="#required-attributes-3">Required attributes</a></h4>
<ul>
<li><code>cargoArtifacts</code>: A path (or derivation) which contains an existing cargo
<code>target</code> directory, which will be reused at the start of the derivation.
Useful for caching incremental cargo builds.
<ul>
<li>This can be prepared via <code>buildDepsOnly</code></li>
<li>Alternatively, any cargo-based derivation which was built with
<code>doInstallCargoArtifacts = true</code> will work as well</li>
</ul>
</li>
</ul>
<h4 id="optional-attributes-7"><a class="header" href="#optional-attributes-7">Optional attributes</a></h4>
<ul>
<li><code>cargoDocExtraArgs</code>: additional flags to be passed in the rustdoc invocation (e.g.
deny specific lints)
<ul>
<li>Default value: <code>"--no-deps"</code></li>
</ul>
</li>
<li><code>cargoExtraArgs</code>: additional flags to be passed in the cargo invocation (e.g.
enabling specific features)
<ul>
<li>Default value: <code>"--locked"</code></li>
</ul>
</li>
<li><code>docInstallRoot</code>: defines the exact directory to install to <code>$out/share</code>,
useful for overriding when compiling different targets. By default will honor
<code>$CARGO_TARGET_DIR</code> (or default to <code>./target</code> if not set) and
<code>$CARGO_BUILD_TARGET</code> (if set).
<ul>
<li>Default value: <code>"${CARGO_TARGET_DIR:-target}/${CARGO_BUILD_TARGET:-}/doc"</code>
if such a directory exists, otherwise falls back to
<code>"${CARGO_TARGET_DIR:-target}/doc"</code></li>
</ul>
</li>
</ul>
<h4 id="remove-attributes-7"><a class="header" href="#remove-attributes-7">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoDocExtraArgs</code></li>
<li><code>cargoExtraArgs</code></li>
</ul>
<h3 id="cranelibcargodoctest"><a class="header" href="#cranelibcargodoctest"><code>craneLib.cargoDocTest</code></a></h3>
<p><code>cargoDocTest :: set -&gt; drv</code></p>
<p>Create a derivation which will run a <code>cargo test --doc</code> invocation in a cargo
workspace. To run all or any tests for a workspace, consider <code>cargoTest</code>.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<ul>
<li><code>buildPhaseCargoCommand</code> will be set to run <code>cargo test --profile release</code> in
the workspace.
<ul>
<li><code>CARGO_PROFILE</code> can be set on the derivation to alter which cargo profile is
selected; setting it to <code>""</code> will omit specifying a profile altogether.</li>
</ul>
</li>
<li><code>pnameSuffix</code> will be set to <code>"-doctest"</code></li>
</ul>
<h4 id="optional-attributes-8"><a class="header" href="#optional-attributes-8">Optional attributes</a></h4>
<ul>
<li><code>cargoExtraArgs</code>: additional flags to be passed in the cargo invocation
<ul>
<li>Default value: <code>"--locked"</code></li>
</ul>
</li>
<li><code>cargoTestExtraArgs</code>: additional flags to be passed in the cargo
invocation
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
</ul>
<h3 id="cranelibcargofmt"><a class="header" href="#cranelibcargofmt"><code>craneLib.cargoFmt</code></a></h3>
<p><code>cargoFmt :: set -&gt; drv</code></p>
<p>Create a derivation which will run a <code>cargo fmt</code> invocation in a cargo
workspace.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<ul>
<li><code>buildPhaseCargoCommand</code> will be set to run <code>cargo fmt</code> (in check mode) in the
workspace.</li>
<li><code>cargoArtifacts</code> is disabled/cleared</li>
<li><code>cargoVendorDir</code> is disabled/cleared</li>
<li><code>pnameSuffix</code> will be set to <code>"-fmt"</code></li>
</ul>
<h4 id="optional-attributes-9"><a class="header" href="#optional-attributes-9">Optional attributes</a></h4>
<ul>
<li><code>cargoExtraArgs</code>: additional flags to be passed in the cargo invocation
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
<li><code>rustFmtExtraArgs</code>: additional flags to be passed in the rustfmt invocation
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
</ul>
<h4 id="native-build-dependencies-3"><a class="header" href="#native-build-dependencies-3">Native build dependencies</a></h4>
<p>The <code>rustfmt</code> package is automatically appended as a native build input to any
other <code>nativeBuildInputs</code> specified by the caller.</p>
<h4 id="remove-attributes-8"><a class="header" href="#remove-attributes-8">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoExtraArgs</code></li>
<li><code>rustFmtExtraArgs</code></li>
</ul>
<h3 id="cranelibtaplofmt"><a class="header" href="#cranelibtaplofmt"><code>craneLib.taploFmt</code></a></h3>
<p><code>taploFmt :: set -&gt; drv</code></p>
<p>Create a derivation which will run a <code>taplo fmt</code> invocation in a cargo
workspace.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<ul>
<li><code>buildPhaseCargoCommand</code> will be set to run <code>taplo fmt</code> (in check mode) in the
workspace.</li>
<li><code>cargoArtifacts</code> is disabled/cleared</li>
<li><code>cargoVendorDir</code> is disabled/cleared</li>
<li><code>pnameSuffix</code> will be set to <code>"-tomlfmt"</code></li>
</ul>
<h4 id="optional-attributes-10"><a class="header" href="#optional-attributes-10">Optional attributes</a></h4>
<ul>
<li><code>taploExtraArgs</code>: additional flags to be passed in the taplo invocation
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
</ul>
<p><code>taplo</code> command line options for setting <code>taploExtraArgs</code> and configuration options
for <code>taplo.toml</code> config files can be found in the <em>Command Line</em> and <em>Configuration</em>
sections of the <a href="https://taplo.tamasfe.dev/">taplo documentation</a>.</p>
<h4 id="native-build-dependencies-4"><a class="header" href="#native-build-dependencies-4">Native build dependencies</a></h4>
<p>The <code>taplo</code> package is automatically appended as a native build input to any
other <code>nativeBuildInputs</code> specified by the caller.</p>
<h4 id="remove-attributes-9"><a class="header" href="#remove-attributes-9">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>taploExtraArgs</code></li>
</ul>
<h3 id="cranelibcargollvmcov"><a class="header" href="#cranelibcargollvmcov"><code>craneLib.cargoLlvmCov</code></a></h3>
<p><code>cargoLlvmCov :: set -&gt; drv</code></p>
<p>Create a derivation which will run a <code>cargo llvm-cov</code> invocation in a cargo
workspace.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<ul>
<li><code>buildPhaseCargoCommand</code> will be set to run <code>cargo llvm-cov test --release</code> in
the workspace.</li>
<li><code>installPhaseCommand</code> will be set to <code>""</code>, as the default settings creates
a file instead of directory at <code>$out</code>.</li>
<li><code>doInstallCargoArtifacts</code> will be set to <code>false</code> for the same reason as
<code>installPhaseCommand</code></li>
<li><code>pnameSuffix</code> will be set to <code>"-llvm-cov"</code></li>
</ul>
<h4 id="required-attributes-4"><a class="header" href="#required-attributes-4">Required attributes</a></h4>
<ul>
<li><code>cargoArtifacts</code>: A path (or derivation) which contains an existing cargo
<code>target</code> directory, which will be reused at the start of the derivation.
Useful for caching incremental cargo builds.
<ul>
<li>This can be prepared via <code>buildDepsOnly</code></li>
<li>Alternatively, any cargo-based derivation which was built with
<code>doInstallCargoArtifacts = true</code> will work as well</li>
</ul>
</li>
</ul>
<h4 id="optional-attributes-11"><a class="header" href="#optional-attributes-11">Optional attributes</a></h4>
<ul>
<li><code>cargoExtraArgs</code>: additional flags to be passed in the cargo invocation
<ul>
<li>Default value: <code>"--locked"</code></li>
</ul>
</li>
<li><code>cargoLlvmCovCommand</code>: cargo-llvm-cov command to run
<ul>
<li>Default value: <code>"test"</code></li>
</ul>
</li>
<li><code>cargoLlvmCovExtraArgs</code>: additional flags to be passed in the cargo
llvm-cov invocation
<ul>
<li>Default value: <code>"--lcov --output-path $out"</code></li>
</ul>
</li>
</ul>
<h4 id="native-build-dependencies-5"><a class="header" href="#native-build-dependencies-5">Native build dependencies</a></h4>
<p>The <code>cargo-llvm-cov</code> package is automatically appended as a native build input to any
other <code>nativeBuildInputs</code> specified by the caller.</p>
<p>Note that this would require the <code>llvm-tools-preview</code> component for the Rust toolchain,
which you would need to provide yourself using fenix or rust-overlay.</p>
<h4 id="remove-attributes-10"><a class="header" href="#remove-attributes-10">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoExtraArgs</code></li>
<li><code>cargoLlvmCovCommand</code></li>
<li><code>cargoLlvmCovExtraArgs</code></li>
</ul>
<h3 id="cranelibcargonextest"><a class="header" href="#cranelibcargonextest"><code>craneLib.cargoNextest</code></a></h3>
<p><code>cargoNextest :: set -&gt; drv</code></p>
<p>Create a derivation which will run a <code>cargo nextest</code> invocation in a cargo
workspace. Note that <a href="https://github.com/nextest-rs/nextest/issues/16"><code>cargo nextest</code> doesn't run
doctests</a>, so you may also
want to build a <code>cargoDocTest</code> derivation.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<ul>
<li><code>checkPhaseCargoCommand</code> will be set to run <code>cargo nextest run --profile release</code>
for the workspace.
<ul>
<li><code>CARGO_PROFILE</code> can be set on the derivation to alter which cargo profile
is selected; setting it to <code>""</code> will omit specifying a profile
altogether.</li>
</ul>
</li>
<li><code>pnameSuffix</code> will be set to <code>"-nextest"</code> and may include partition numbers</li>
</ul>
<h4 id="required-attributes-5"><a class="header" href="#required-attributes-5">Required attributes</a></h4>
<ul>
<li><code>cargoArtifacts</code>: A path (or derivation) which contains an existing cargo
<code>target</code> directory, which will be reused at the start of the derivation.
Useful for caching incremental cargo builds.
<ul>
<li>This can be prepared via <code>buildDepsOnly</code></li>
<li>Alternatively, any cargo-based derivation which was built with
<code>doInstallCargoArtifacts = true</code> will work as well</li>
</ul>
</li>
</ul>
<h4 id="optional-attributes-12"><a class="header" href="#optional-attributes-12">Optional attributes</a></h4>
<ul>
<li><code>buildPhaseCargoCommand</code>, unless specified, will be set to print the nextest version</li>
<li><code>cargoExtraArgs</code>: additional flags to be passed in the cargo invocation (e.g.
enabling specific features)
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
<li><code>cargoLlvmCovExtraArgs</code>: additional flags to be passed in the cargo
llvm-cov invocation
<ul>
<li>Default value: <code>"--lcov --output-path $out/coverage"</code></li>
</ul>
</li>
<li><code>cargoNextestExtraArgs</code>: additional flags to be passed in the nextest invocation
(e.g. specifying a profile)
<ul>
<li>Default value: <code>""</code></li>
<li>Note that all flags from <code>cargo test</code> are supported.</li>
</ul>
</li>
<li><code>cargoNextestPartitionsExtraArgs</code>: additional flags to be passed in the nextest partition invocation
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
<li><code>partitions</code>: The number of separate nextest partitions to run. Useful if the
test suite takes a long time and can be parallelized across multiple build
nodes.
<ul>
<li>Default value: <code>1</code></li>
</ul>
</li>
<li><code>partitionType</code>: The kind of nextest partition to run (e.g. <code>"count"</code> or
<code>"hash"</code> based).
<ul>
<li>Default value: <code>"count"</code></li>
</ul>
</li>
<li><code>withLlvmCov</code>: Whether or not to run nextest through <code>cargo llvm-cov</code>
<ul>
<li>Default value: <code>false</code></li>
<li>Note that setting <code>withLlvmCov = true;</code> is not currently supported if
<code>partitions &gt; 1</code>.</li>
</ul>
</li>
</ul>
<h4 id="native-build-dependencies-6"><a class="header" href="#native-build-dependencies-6">Native build dependencies</a></h4>
<p>The <code>cargo-nextest</code> package is automatically appended as a native build input to any
other <code>nativeBuildInputs</code> specified by the caller.</p>
<h4 id="remove-attributes-11"><a class="header" href="#remove-attributes-11">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoExtraArgs</code></li>
<li><code>cargoLlvmCovExtraArgs</code></li>
<li><code>cargoNextestExtraArgs</code></li>
<li><code>cargoNextestPartitionsExtraArgs</code></li>
<li><code>partitions</code></li>
<li><code>partitionType</code></li>
<li><code>withLlvmCov</code></li>
</ul>
<h3 id="cranelibcargotarpaulin"><a class="header" href="#cranelibcargotarpaulin"><code>craneLib.cargoTarpaulin</code></a></h3>
<p><code>cargoTarpaulin :: set -&gt; drv</code></p>
<p>Create a derivation which will run a <code>cargo tarpaulin</code> invocation in a cargo
workspace.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<ul>
<li><code>buildPhaseCargoCommand</code> will be set to run <code>cargo tarpaulin --profile release</code> in
the workspace.
<ul>
<li><code>CARGO_PROFILE</code> can be set on the derivation to alter which cargo profile is
selected; setting it to <code>""</code> will omit specifying a profile altogether.</li>
</ul>
</li>
<li><code>pnameSuffix</code> will be set to <code>"-tarpaulin"</code></li>
</ul>
<h4 id="required-attributes-6"><a class="header" href="#required-attributes-6">Required attributes</a></h4>
<ul>
<li><code>cargoArtifacts</code>: A path (or derivation) which contains an existing cargo
<code>target</code> directory, which will be reused at the start of the derivation.
Useful for caching incremental cargo builds.
<ul>
<li>This can be prepared via <code>buildDepsOnly</code></li>
<li>Alternatively, any cargo-based derivation which was built with
<code>doInstallCargoArtifacts = true</code> will work as well</li>
</ul>
</li>
</ul>
<h4 id="optional-attributes-13"><a class="header" href="#optional-attributes-13">Optional attributes</a></h4>
<ul>
<li><code>cargoExtraArgs</code>: additional flags to be passed in the cargo invocation
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
<li><code>cargoTarpaulinExtraArgs</code>: additional flags to be passed in the cargo
tarpaulin invocation
<ul>
<li>Default value: <code>"--skip-clean --out xml --output-dir $out"</code></li>
</ul>
</li>
<li><code>doNotLinkInheritedArtifacts</code> will be set to <code>true</code> if not specified.</li>
</ul>
<h4 id="native-build-dependencies-7"><a class="header" href="#native-build-dependencies-7">Native build dependencies</a></h4>
<p>The <code>cargo-tarpaulin</code> package is automatically appended as a native build input to any
other <code>nativeBuildInputs</code> specified by the caller.</p>
<h4 id="remove-attributes-12"><a class="header" href="#remove-attributes-12">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoExtraArgs</code></li>
<li><code>cargoTarpaulinExtraArgs</code></li>
</ul>
<h3 id="cranelibcargotest"><a class="header" href="#cranelibcargotest"><code>craneLib.cargoTest</code></a></h3>
<p><code>cargoTest :: set -&gt; drv</code></p>
<p>Create a derivation which will run a <code>cargo test</code> invocation in a cargo
workspace.</p>
<p>Except where noted below, all derivation attributes are delegated to
<code>mkCargoDerivation</code>, and can be used to influence its behavior.</p>
<ul>
<li><code>buildPhaseCargoCommand</code> will be set to run <code>cargo test --profile release</code> in
the workspace.
<ul>
<li><code>CARGO_PROFILE</code> can be set on the derivation to alter which cargo profile is
selected; setting it to <code>""</code> will omit specifying a profile altogether.</li>
</ul>
</li>
<li><code>pnameSuffix</code> will be set to <code>"-test"</code></li>
</ul>
<h4 id="optional-attributes-14"><a class="header" href="#optional-attributes-14">Optional attributes</a></h4>
<ul>
<li><code>cargoExtraArgs</code>: additional flags to be passed in the cargo invocation
<ul>
<li>Default value: <code>"--locked"</code></li>
</ul>
</li>
<li><code>cargoTestExtraArgs</code>: additional flags to be passed in the cargo
invocation
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
</ul>
<h4 id="remove-attributes-13"><a class="header" href="#remove-attributes-13">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoExtraArgs</code></li>
<li><code>cargoTestExtraArgs</code></li>
</ul>
<h4 id="remove-attributes-14"><a class="header" href="#remove-attributes-14">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>mkCargoDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>cargoExtraArgs</code></li>
<li><code>cargoTestExtraArgs</code></li>
</ul>
<h3 id="cranelibcleancargosource"><a class="header" href="#cranelibcleancargosource"><code>craneLib.cleanCargoSource</code></a></h3>
<p><code>cleanCargoSource :: path or drv -&gt; drv</code></p>
<p>Cleans a source tree to omit things like version control directories as well
omit any non-Rust/non-cargo related files. Useful to avoid rebuilding a project
when unrelated files are changed (e.g. <code>flake.nix</code> or any other nix files).</p>
<p>The final output will be cleaned by both <code>cleanSource</code> (from nixpkgs) and
<code>craneLib.filterCargoSources</code>. See each of them for more details on which files are
kept.</p>
<p>If it is necessary to customize which files are kept, a custom filter can be
written (which may want to also call <code>craneLib.filterCargoSources</code>) to achieve the
desired behavior.</p>
<pre><code class="language-nix">craneLib.cleanCargoSource ./.
</code></pre>
<h3 id="cranelibcleancargotoml"><a class="header" href="#cranelibcleancargotoml"><code>craneLib.cleanCargoToml</code></a></h3>
<p><code>cleanCargoToml :: set -&gt; set</code></p>
<p>Cleans all definitions from a Cargo.toml file which are irrelevant for a
minimal build of a package's dependencies. See <code>mkDummySrc</code> for more information
on how the result is applied.</p>
<p>In general, the following types of attributes are kept from the original input:</p>
<ul>
<li>basic package definitions (like name and version)</li>
<li>dependency definitions</li>
<li>feature definitions</li>
<li>workspace definitions</li>
<li>anything pertaining to project structure (like bin/lib targets, tests, etc.)</li>
</ul>
<pre><code class="language-nix">craneLib.cleanCargoToml { cargoToml = ./Cargo.toml; }
# { dependencies = { byteorder = "*"; }; package = { edition = "2021"; name = "simple"; version = "0.1.0"; }; }
</code></pre>
<h4 id="input-attributes"><a class="header" href="#input-attributes">Input attributes</a></h4>
<ul>
<li><code>cargoToml</code>: a path to a Cargo.toml file</li>
<li><code>cargoTomlContents</code>: the contents of a Cargo.toml file as a string</li>
</ul>
<p>At least one of the above attributes must be specified, or an error will be
raised during evaluation.</p>
<h3 id="cranelibcratenamefromcargotoml"><a class="header" href="#cranelibcratenamefromcargotoml"><code>craneLib.crateNameFromCargoToml</code></a></h3>
<p><code>crateNameFromCargoToml :: set -&gt; set</code></p>
<p>Extract a crate's name and version from its Cargo.toml file.</p>
<p>The resulting <code>pname</code> attribute will be populated with the value of the
Cargo.toml's (top-level) attributes in the following order, where the first
attribute (with a string value) will be chosen:</p>
<ol>
<li><code>package.metadata.crane.name</code></li>
<li><code>package.name</code></li>
<li><code>workspace.metadata.crane.name</code></li>
<li>(Deprecated) <code>workspace.package.name</code></li>
<li>Otherwise a placeholder name will be used</li>
</ol>
<p>The resulting <code>version</code> attribute will be populated with the value of the
Cargo.toml's (top-level) attributes in the following order, where the first
attribute (with a string value) will be chosen:</p>
<ol>
<li><code>package.version</code></li>
<li><code>workspace.package.version</code></li>
<li>Otherwise a placeholder version will be used</li>
</ol>
<p>Note that <em>only the root <code>Cargo.toml</code> of the specified source will be checked</em>.
Directories <strong>will not be crawled</strong> to resolve potential workspace inheritance.</p>
<pre><code class="language-nix">craneLib.crateNameFromCargoToml { cargoToml = ./Cargo.toml; }
# { pname = "simple"; version = "0.1.0"; }
</code></pre>
<h3 id="cranelibcrateregistries"><a class="header" href="#cranelibcrateregistries"><code>craneLib.crateRegistries</code></a></h3>
<p><code>crateRegistries :: set</code></p>
<p>A set of crate registries made available for use in downloading crate sources.
The keys are registry URLs as used in the Cargo.lock file (e.g.
"registry+https://...") and the values are the download URL for that registry,
including any <a href="https://doc.rust-lang.org/cargo/reference/registries.html#index-format">placeholder
values</a>
cargo is expected to populate for downloads.</p>
<p>This definition can be updated via <code>appendCrateRegistries</code>.</p>
<h4 id="input-attributes-1"><a class="header" href="#input-attributes-1">Input attributes</a></h4>
<ul>
<li><code>src</code>: a directory which includes a Cargo.toml file at its root.</li>
<li><code>cargoToml</code>: a path to a Cargo.toml file</li>
<li><code>cargoTomlContents</code>: the contents of a Cargo.toml file as a string</li>
</ul>
<p>At least one of the above attributes must be specified, or an error will be
raised during evaluation.</p>
<h4 id="output-attributes"><a class="header" href="#output-attributes">Output attributes</a></h4>
<ul>
<li><code>pname</code>: the name of the crate
<ul>
<li>Default value: <code>"cargo-package"</code> if the specified Cargo.toml file did not
include a name</li>
</ul>
</li>
<li><code>version</code>: the version of the crate
<ul>
<li>Default value: <code>"0.0.1"</code> if the specified Cargo.toml file did not
include a version</li>
</ul>
</li>
</ul>
<h3 id="cranelibdevshell"><a class="header" href="#cranelibdevshell"><code>craneLib.devShell</code></a></h3>
<p><code>devShell :: set -&gt; drv</code></p>
<p>A thin wrapper around
<a href="https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-mkShell"><code>pkgs.mkShell</code></a> for
creating development shells for use with <code>nix develop</code> (see <a href="local_development.html">“Local
Development”</a>). Except where noted below, all derivation
attributes are passed straight through, so any <code>mkShell</code> behavior can be used
as expected: namely, all key-value pairs other than those <code>mkShell</code> consumes
will be set as environment variables in the resulting shell.</p>
<p>Note that the current toolchain's <code>cargo</code>, <code>clippy</code>, <code>rustc</code>, and <code>rustfmt</code>
packages will automatically be added to the devShell.</p>
<h4 id="optional-attributes-15"><a class="header" href="#optional-attributes-15">Optional attributes</a></h4>
<ul>
<li><code>checks</code>: A set of checks to inherit inputs from, typically
<code>self.checks.${system}</code>. Build inputs from the values in this attribute set
are added to the created shell environment for interactive use.</li>
<li><code>inputsFrom</code>: A list of extra packages to inherit inputs from. Note that
these packages are <em>not</em> added to the result environment; use
<code>packages</code> for that.</li>
<li><code>packages</code>: A list of extra packages to add to the created shell environment.</li>
<li><code>shellHook</code>: A string of bash statements that will be executed when the shell
is entered with <code>nix develop</code>.</li>
</ul>
<p>See the <a href="examples/quick-start.html">quick start example</a> for usage in a
<code>flake.nix</code> file.</p>
<pre><code class="language-nix">craneLib.devShell {
  checks = self.checks.${system};

  packages = [
    pkgs.ripgrep
  ];

  # Set a `cargo-nextest` profile:
  NEXTEST_PROFILE = "local";
}
</code></pre>
<pre><code class="language-nix">craneLib.devShell {
  checks = {
    my-package-clippy = craneLib.cargoClippy commonArgs;
    my-package-doc = craneLib.cargoDoc commonArgs;
    my-package-nextest = craneLib.cargoNextest commonArgs;
  };
}
</code></pre>
<p>Note that it is possible to override the underlying <code>mkShell</code> (for example to
customize the build environment further) like so:</p>
<pre><code class="language-nix">let
  moldDevShell = craneLib.devShell.override {
    # For example, use the mold linker
    mkShell = pkgs.mkShell.override {
      stdenv = pkgs.stdenvAdapters.useMoldLinker pkgs.stdenv;
    };
  };
in
moldDevShell {
  packages = [
    # etc...
  ];
}
</code></pre>
<h3 id="cranelibdownloadcargopackage"><a class="header" href="#cranelibdownloadcargopackage"><code>craneLib.downloadCargoPackage</code></a></h3>
<p><code>downloadCargoPackage :: set -&gt; drv</code></p>
<p>Download a packaged cargo crate (e.g. from crates.io) and prepare it for
vendoring.</p>
<p>The registry's <code>fetchurlExtraArgs</code> will be passed through to <code>fetchurl</code> when
downloading the crate, making it possible to influence interacting with the
registry's API if necessary.</p>
<h4 id="required-input-attributes"><a class="header" href="#required-input-attributes">Required input attributes</a></h4>
<ul>
<li><code>checksum</code>: the (sha256) checksum recorded in the Cargo.lock file</li>
<li><code>name</code>: the name of the crate</li>
<li><code>source</code>: the source key recorded in the Cargo.lock file</li>
<li><code>version</code>: the version of the crate</li>
</ul>
<h4 id="attributes-of-the-vendor-prep-derivation"><a class="header" href="#attributes-of-the-vendor-prep-derivation">Attributes of the vendor-prep derivation</a></h4>
<ul>
<li><code>dontBuild</code>: <code>true</code></li>
<li><code>dontConfigure</code>: <code>true</code></li>
<li><code>dontFixup</code>: <code>true</code></li>
<li><code>pname</code>: <code>"cargo-package-"</code> suffixed by the package name in <code>Cargo.lock</code></li>
<li><code>sourceRoot</code>: <code>"./crate"</code></li>
<li><code>version</code>: inherited from the package version in <code>Cargo.lock</code></li>
<li><code>unpackPhase</code>: This phase will:
<ol>
<li>run the <code>preUnpack</code> hook</li>
<li>create an empty directory named <code>./crate</code></li>
<li>unpack the crate's tarball under <code>./crate</code></li>
<li>run the <code>postUnpack</code> hook</li>
</ol>
</li>
<li><code>installPhase</code>: This phase will:
<ol>
<li>run the <code>preInstall</code> hook</li>
<li>move the contents of the current directory (i.e. <code>./crate</code> by default) to
<code>$out</code></li>
<li>populate <code>$out/.cargo-checksum.json</code></li>
<li>run the <code>postInstall</code> hook</li>
</ol>
</li>
</ul>
<h3 id="cranelibdownloadcargopackagefromgit"><a class="header" href="#cranelibdownloadcargopackagefromgit"><code>craneLib.downloadCargoPackageFromGit</code></a></h3>
<p><code>downloadCargoPackageFromGit :: set -&gt; drv</code></p>
<p>Download a git repository containing a cargo crate or workspace, and prepare it
any crates it contains for vendoring.</p>
<h4 id="required-input-attributes-1"><a class="header" href="#required-input-attributes-1">Required input attributes</a></h4>
<ul>
<li><code>git</code>: the URL to the repository</li>
<li><code>rev</code>: the exact revision to check out</li>
</ul>
<h4 id="optional-attributes-16"><a class="header" href="#optional-attributes-16">Optional attributes</a></h4>
<ul>
<li><code>allRefs</code>: whether all git refs should be fetched in order to look for the
specified <code>rev</code>
<ul>
<li>Default value: <code>true</code> if <code>ref</code> is set to <code>null</code>, <code>false</code> otherwise</li>
</ul>
</li>
<li><code>ref</code>: the ref (i.e. branch or tag) to which <code>rev</code> belongs to. For branches it
should be <code>"refs/head/${branch}"</code> and for tags it should be
<code>"refs/tags/${tag}"</code>
<ul>
<li>Default value: <code>null</code></li>
</ul>
</li>
<li><code>sha256</code>: the sha256 hash of the (unpacked) download. If provided <code>fetchgit</code> will be used
(instead of <code>builtins.fetchGit</code>) which allows for offline evaluations.
<ul>
<li>Default value: <code>null</code></li>
</ul>
</li>
</ul>
<h4 id="attributes-of-the-vendor-prep-derivation-1"><a class="header" href="#attributes-of-the-vendor-prep-derivation-1">Attributes of the vendor-prep derivation</a></h4>
<ul>
<li><code>depsBuildBuild</code>: a list of the following packages:
<ul>
<li><code>cargo</code></li>
<li><code>craneUtils</code></li>
<li><code>jq</code></li>
<li><code>remarshal</code></li>
<li><code>ripgrep</code></li>
</ul>
</li>
<li><code>dontBuild</code>: <code>true</code></li>
<li><code>dontConfigure</code>: <code>true</code></li>
<li><code>dontFixup</code>: <code>true</code></li>
<li><code>installPhase</code>: This phase will:
<ol>
<li>run the <code>preInstall</code> hook</li>
<li>Prepare the current directory for vendoring by:
<ul>
<li>Searching for all <code>Cargo.toml</code> files</li>
<li>Copying their parent directory to <code>$out/$crate</code> (where <code>$crate</code> is the
package name and version as defined in <code>Cargo.toml</code>)</li>
<li>Populating <code>.cargo-checksum.json</code></li>
<li>Running <code>crane-resolve-workspace-inheritance</code> on the <code>Cargo.toml</code></li>
<li>Note that duplicate crates (whose name and version collide) are ignored</li>
</ul>
</li>
<li>run the <code>postInstall</code> hook</li>
</ol>
</li>
<li><code>name</code>: set to <code>"cargo-git"</code></li>
<li><code>src</code>: the git repo checkout, as determined by the input parameters</li>
</ul>
<h3 id="cranelibfindcargofiles"><a class="header" href="#cranelibfindcargofiles"><code>craneLib.findCargoFiles</code></a></h3>
<p><code>findCargoFiles :: path -&gt; set of lists</code></p>
<p>Given a path, recursively search it for any <code>Cargo.toml</code>, <code>.cargo/config</code> or
<code>.cargo/config.toml</code> files.</p>
<pre><code class="language-nix">craneLib.findCargoFiles ./src
# { cargoTomls = [ "..." ]; cargoConfigs = [ "..." ]; }
</code></pre>
<h3 id="cranelibfiltercargosources"><a class="header" href="#cranelibfiltercargosources"><code>craneLib.filterCargoSources</code></a></h3>
<p><code>filterCargoSources :: path -&gt; string -&gt; bool</code></p>
<p>A source filter which when used with <code>cleanSourceWith</code> (from nixpkgs's <code>lib</code>)
will retain the following files from a given source:</p>
<ul>
<li>Cargo files (<code>Cargo.toml</code>, <code>Cargo.lock</code>, <code>.cargo/config.toml</code>, <code>.cargo/config</code>)</li>
<li>Rust files (files whose name end with <code>.rs</code>)</li>
<li>TOML files (files whose name end with <code>.toml</code>)</li>
</ul>
<pre><code class="language-nix">cleanSourceWith {
  src = ./.;
  filter = craneLib.filterCargoSources;
  name = "source"; # Be reproducible, regardless of the directory name
}
</code></pre>
<p>Note that it is possible to compose source filters, especially if
<code>filterCargoSources</code> omits files which are relevant to the build. For example:</p>
<pre><code class="language-nix">let
  # Only keeps markdown files
  markdownFilter = path: _type: builtins.match ".*md$" path != null;
  markdownOrCargo = path: type:
    (markdownFilter path type) || (craneLib.filterCargoSources path type);
in
cleanSourceWith {
  src = ./.;
  filter = markdownOrCargo;
  name = "source"; # Be reproducible, regardless of the directory name
}
</code></pre>
<h3 id="cranelibfilesetcargotomlandlock"><a class="header" href="#cranelibfilesetcargotomlandlock"><code>craneLib.fileset.cargoTomlAndLock</code></a></h3>
<p><code>cargoTomlAndLock :: path -&gt; fileset</code></p>
<p>A <a href="https://nixos.org/manual/nixpkgs/unstable/#sec-functions-library-fileset">fileset</a> helper which will only include any <code>Cargo.toml</code> and <code>Cargo.lock</code>
files from the specified path.</p>
<h3 id="cranelibfilesetcommoncargosources"><a class="header" href="#cranelibfilesetcommoncargosources"><code>craneLib.fileset.commonCargoSources</code></a></h3>
<p><code>commonCargoSources :: path -&gt; fileset</code></p>
<p>A <a href="https://nixos.org/manual/nixpkgs/unstable/#sec-functions-library-fileset">fileset</a> helper which will only include any files commonly used by cargo
projects from the specified path. Essentially a union of:</p>
<ul>
<li><code>craneLib.fileset.cargoTomlAndLock</code></li>
<li><code>craneLib.fileset.rust</code></li>
<li><code>craneLib.fileset.toml</code></li>
</ul>
<h3 id="cranelibfilesetconfigtoml"><a class="header" href="#cranelibfilesetconfigtoml"><code>craneLib.fileset.configToml</code></a></h3>
<p><code>configToml :: path -&gt; fileset</code></p>
<p>A <a href="https://nixos.org/manual/nixpkgs/unstable/#sec-functions-library-fileset">fileset</a> helper which will only include <code>config.toml</code> files from the
specified path.</p>
<p>Note that cargo usually only pays attention to <code>config.toml</code> files if they are
present inside of a directory named <code>.cargo</code>. This fileset will contain any
<code>config.toml</code> file, even if its parent directory is <em>not</em> named <code>.cargo</code>.</p>
<h3 id="cranelibfilesetrust"><a class="header" href="#cranelibfilesetrust"><code>craneLib.fileset.rust</code></a></h3>
<p><code>rust :: path -&gt; fileset</code></p>
<p>A <a href="https://nixos.org/manual/nixpkgs/unstable/#sec-functions-library-fileset">fileset</a> helper which will only include <code>*.rs</code> files from the specified path.</p>
<h3 id="cranelibfilesettoml"><a class="header" href="#cranelibfilesettoml"><code>craneLib.fileset.toml</code></a></h3>
<p><code>toml :: path -&gt; fileset</code></p>
<p>A <a href="https://nixos.org/manual/nixpkgs/unstable/#sec-functions-library-fileset">fileset</a> helper which will only include <code>*.toml</code> files from the specified path.</p>
<h3 id="cranelibmkcargoderivation"><a class="header" href="#cranelibmkcargoderivation"><code>craneLib.mkCargoDerivation</code></a></h3>
<p><code>mkCargoDerivation :: set -&gt; drv</code></p>
<p>A thin wrapper around <code>stdenv.mkDerivation</code> which includes common hooks for
building a derivation using cargo. Except where noted below, all derivation
attributes are passed straight through, so any common derivation behavior can be
used as expected: namely all key-value pairs will be set as environment
variables for the derivation's build script.</p>
<p>This is a fairly low-level abstraction, so consider using <code>buildPackage</code> or
<code>cargoBuild</code> if they fit your needs.</p>
<h4 id="required-attributes-7"><a class="header" href="#required-attributes-7">Required attributes</a></h4>
<ul>
<li><code>buildPhaseCargoCommand</code>: A command (likely a cargo invocation) to run during
the derivation's build phase. Pre and post build hooks will automatically be
run.</li>
<li><code>cargoArtifacts</code>: A path (or derivation) which contains an existing cargo
<code>target</code> directory, which will be reused at the start of the derivation.
Useful for caching incremental cargo builds.
<ul>
<li>This can be prepared via <code>buildDepsOnly</code></li>
<li>Alternatively, any cargo-based derivation which was built with
<code>doInstallCargoArtifacts = true</code> will work as well</li>
</ul>
</li>
</ul>
<h4 id="optional-attributes-17"><a class="header" href="#optional-attributes-17">Optional attributes</a></h4>
<ul>
<li><code>buildPhase</code>: the commands used by the build phase of the derivation
<ul>
<li>Default value: the build phase will run <code>preBuild</code> hooks, print the cargo
version, log and evaluate <code>buildPhaseCargoCommand</code>, and run <code>postBuild</code>
hooks</li>
</ul>
</li>
<li><code>cargoLock</code>: if set will be passed through to the derivation and the path it
points to will be copied as the workspace <code>Cargo.lock</code>
<ul>
<li>Unset by default</li>
</ul>
</li>
<li><code>cargoLockContents</code>: if set and <code>cargoLock</code> is missing or null, its value will
be written as the workspace <code>Cargo.lock</code>
<ul>
<li>Unset by default</li>
</ul>
</li>
<li><code>cargoLockParsed</code>: if set and both <code>cargoLock</code> and <code>cargoLockContents</code> are
missing or null, its value will be serialized as TOML and the result written
as the workspace <code>Cargo.lock</code>
<ul>
<li>Unset by default</li>
</ul>
</li>
<li><code>cargoVendorDir</code>: A path (or derivation) of vendored cargo sources which can
be consumed without network access. Directory structure should basically
follow the output of <code>cargo vendor</code>.
<ul>
<li>Default value: the result of <code>vendorCargoDeps</code> after applying the arguments
set (with the respective default values)</li>
</ul>
</li>
<li><code>checkPhase</code>: the commands used by the check phase of the derivation
<ul>
<li>Default value: the check phase will run <code>preCheck</code> hooks, log and evaluate
<code>checkPhaseCargoCommand</code>, and run <code>postCheck</code> hooks</li>
</ul>
</li>
<li><code>checkPhaseCargoCommand</code>: A command (likely a cargo invocation) to run during
the derivation's check phase. Pre and post check hooks will automatically be
run.
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
<li><code>configurePhase</code>: the commands used by the configure phase of the derivation
<ul>
<li>Default value: the configure phase will run <code>preConfigureHooks</code> hooks, then
run <code>postConfigure</code> hooks</li>
</ul>
</li>
<li><code>doIncludeCrossToolchainEnv</code>: enables the default configuration of the
cross-compilation toolchain using <code>mkCrossToolchainEnv</code>. Useful if you want to
perform this configuration yourself.
<ul>
<li>Default value: <code>true</code></li>
</ul>
</li>
<li><code>doInstallCargoArtifacts</code>: controls whether cargo's <code>target</code> directory should
be copied as an output
<ul>
<li>Default value: <code>true</code></li>
</ul>
</li>
<li><code>installPhase</code>: the commands used by the install phase of the derivation
<ul>
<li>Default value: the install phase will run <code>preInstall</code> hooks, log and evaluate
<code>installPhaseCommand</code>, and run <code>postInstall</code> hooks</li>
</ul>
</li>
<li><code>installPhaseCommand</code>: the command(s) which are expected to install the
derivation's outputs.
<ul>
<li>Default value: <code>"mkdir -p $out"</code></li>
<li>By default an output directory is created such that any other <code>postInstall</code>
hooks can successfully run. Consider overriding this value with an
appropriate installation commands for the package being built.</li>
</ul>
</li>
<li><code>pname</code>: the name of the derivation
<ul>
<li>Default value: the package name listed in <code>Cargo.toml</code></li>
</ul>
</li>
<li><code>pnameSuffix</code>: a suffix appended to <code>pname</code>
<ul>
<li>Default value: <code>""</code></li>
</ul>
</li>
<li><code>stdenv</code>: a function to select the standard build environment to use for this
derivation. For backwards compatibility a non-function value (i.e. <code>stdenv = pkgs.stdenv;</code>) will still be accepted.
<ul>
<li>Default value: <code>p: p.stdenv</code></li>
</ul>
</li>
<li><code>version</code>: the version of the derivation
<ul>
<li>Default value: the version listed in <code>Cargo.toml</code></li>
</ul>
</li>
</ul>
<h4 id="remove-attributes-15"><a class="header" href="#remove-attributes-15">Remove attributes</a></h4>
<p>The following attributes will be removed before being lowered to
<code>stdenv.mkDerivation</code>. If you absolutely need these attributes present as
environment variables during the build, you can bring them back via
<code>.overrideAttrs</code>.</p>
<ul>
<li><code>buildPhaseCargoCommand</code></li>
<li><code>cargoLock</code></li>
<li><code>cargoLockContents</code></li>
<li><code>cargoLockParsed</code></li>
<li><code>checkPhaseCargoCommand</code></li>
<li><code>installPhaseCommand</code></li>
<li><code>outputHashes</code></li>
<li><code>pnameSuffix</code></li>
<li><code>stdenv</code></li>
</ul>
<h4 id="native-build-dependencies-and-included-hooks-2"><a class="header" href="#native-build-dependencies-and-included-hooks-2">Native build dependencies and included hooks</a></h4>
<p>The following packages and hooks are automatically appended as a native build
input to any other <code>nativeBuildInputs</code> specified by the caller:</p>
<ul>
<li><code>cargo</code></li>
<li><code>cargoHelperFunctionsHook</code></li>
<li><code>configureCargoCommonVarsHook</code></li>
<li><code>configureCargoVendoredDepsHook</code></li>
<li><code>inheritCargoArtifactsHook</code></li>
<li><code>installCargoArtifactsHook</code></li>
<li><code>replaceCargoLockHook</code></li>
<li><code>rustc</code></li>
<li><code>rsync</code></li>
<li><code>zstd</code></li>
</ul>
<h3 id="cranelibmkcrosstoolchainenv"><a class="header" href="#cranelibmkcrosstoolchainenv"><code>craneLib.mkCrossToolchainEnv</code></a></h3>
<p><code>mkCrossToolchainEnv :: (set -&gt; drv) -&gt; set</code></p>
<p>A method which returns a set of derivation arguments to configure the Rust
toolchain for cross compilation. This configures both the target and host
toolchains, setting environment variables both for <code>cargo</code> as well as for the
<code>cc</code> crate. If the given <code>pkgs</code> instance is not set up for cross compilation, an
empty set is returned.</p>
<p>The input should be a function which takes an instantiation of <code>pkgs</code>, returning
the <code>stdenv</code> to use for this target.</p>
<pre><code class="language-nix">mkCrossToolchainEnv (p: p.clangStdenv)
</code></pre>
<h3 id="cranelibmkdummysrc"><a class="header" href="#cranelibmkdummysrc"><code>craneLib.mkDummySrc</code></a></h3>
<p><code>mkDummySrc :: set -&gt; drv</code></p>
<p>Converts a given source directory of a cargo workspace to the smallest, most
trivial form needed to build all dependencies such that their artifacts can be
cached.</p>
<p>The actual source files of the project itself are ignored/replaced with
empty programs, such that changes to the source files does not invalidate any
build caches. More specifically:</p>
<ul>
<li>The Cargo.lock file is kept as-is
<ul>
<li>Any changes to it will invalidate the build cache</li>
</ul>
</li>
<li>Any cargo configuration files (i.e. files name <code>config</code> or <code>config.toml</code> whose
parent directory is named <code>.cargo</code>) are kept as-is.
<ul>
<li>Any changes to these files will invalidate the build cache</li>
</ul>
</li>
<li>Any files named <code>Cargo.toml</code> are reduced via <code>cleanCargoToml</code> and the result
is kept. Only the following changes will result in invalidating the build
cache:
<ul>
<li>Any changes to listed dependencies</li>
<li>Any changes to feature definitions</li>
<li>Any changes to the workspace member metadata</li>
<li>Any changes to the <code>[package]</code> definition such as name and version</li>
<li>Any changes to the name or path of any target (such as benches, bins,
examples, libs, or tests)</li>
<li>Any removal or new definition of a <code>[[bin]]</code> target, or, any removal or new
definition of a file under <code>src/bin</code> when <code>autolib</code> is enabled in the
<code>Cargo.toml</code> file (this setting is <code>true</code> by default)</li>
</ul>
</li>
</ul>
<h4 id="required-attributes-8"><a class="header" href="#required-attributes-8">Required attributes</a></h4>
<ul>
<li><code>src</code>: a source directory which should be turned into a "dummy" form</li>
</ul>
<h4 id="optional-attributes-18"><a class="header" href="#optional-attributes-18">Optional attributes</a></h4>
<ul>
<li><code>cargoLock</code>: a path to a Cargo.lock file
<ul>
<li>Default value: <code>src + /Cargo.lock</code></li>
</ul>
</li>
<li><code>dummyrs</code>: a path to a file which will be used in place of all dummy rust
files (e.g. <code>main.rs</code>, <code>lib.rs</code>, etc.). This can be useful to customize dummy
source files (e.g. enable certain lang features for a given target).
<ul>
<li>Default value: an empty <code>fn main</code> declaration and conditionally enabled
<code>#![no_std]</code> if the <code>target_os</code> cfg is set to <code>"none"</code> or <code>"uefi"</code>.</li>
</ul>
</li>
<li><code>dummyBuildrs</code>: similar to <code>dummyrs</code> but will only be used in place of build
scripts
<ul>
<li>Default value: <code>dummyrs</code>, if specified, otherwise, an empty <code>fn main</code>
declaration and conditionally enabled <code>#![no_std]</code> if the <code>target_os</code> cfg is
set to <code>"none"</code> or <code>"uefi"</code>.</li>
</ul>
</li>
<li><code>extraDummyScript</code>: additional shell script which will be run inside the builder
verbatim. Useful for customizing what the dummy sources include by running any
arbitrary commands.
<ul>
<li>Default value: <code>""</code></li>
<li>Note that this script will run in an environment
<em>where the original source is not present</em> as doing so would cause a rebuild
if any part of the source changed. Additional files can be copied to the
derivation's result, but care must be taken that the derivation only depends
on (i.e. is rebuilt if) the smallest subset of the original source as
required.</li>
<li>Here is an example of how to include an entire directory, in this case
<code>.cargo</code>, but any other directory would work as well:
<pre><code class="language-nix">let
  # The _entire_ source of the project. mkDummySrc will automatically
  # filter out irrelevant files as described above
  src = craneLib.path ./.;

  dotCargoOnly = lib.cleanSourceWith {
    inherit src;
    # Only keep `*/.cargo/*`
    filter = path: _type: lib.hasInfix ".cargo" path;
  };
in
mkDummySrc {
  inherit src;

  # Note that here we scope the path to only contain any `.cargo` directory
  # and its contents and not any other  directories which may exist at the
  # root of the project. Also note that the entire path is inside of the
  # `${ }` which ensures that the derivation only consumes that directory.
  # Writing `${./.}/.cargo` would incorrectly consume the entire source root,
  # and therefore rebuild everything when any file changes, which defeats
  # artifact caching.
  #
  # Also note the `--no-target-directory` flag which ensures the results are
  # copied to `$out/.cargo` instead of something like `$out/HASH-.cargo`
  extraDummyScript = ''
    cp -r ${dotCargoOnly} --no-target-directory $out/
  '';
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="craneliboverridetoolchain"><a class="header" href="#craneliboverridetoolchain"><code>craneLib.overrideToolchain</code></a></h3>
<p><code>overrideToolchain :: (set -&gt; drv) -&gt; set</code>
<code>overrideToolchain :: drv -&gt; set</code> (legacy)</p>
<p>A convenience method to override and use tools (like <code>cargo</code>, <code>clippy</code>,
<code>rustfmt</code>, <code>rustc</code>, etc.) from one specific toolchain. The input should be a
single derivation which contains all the tools as binaries. For example, this
can be the output of <code>oxalica/rust-overlay</code>.</p>
<p>Note that in order to best support cross compilation, <code>overrideToolchain</code> should
be provided a function (whose argument is a cross-compilation aware version of
<code>pkgs</code>) which constructs the toolchain:</p>
<pre><code class="language-nix">craneLib.overrideToolchain (p: myCustomToolchainForPkgs p)
</code></pre>
<h3 id="cranelibpath"><a class="header" href="#cranelibpath"><code>craneLib.path</code></a></h3>
<p><code>path :: path -&gt; drv</code></p>
<p><code>path :: set -&gt; drv</code></p>
<p>A convenience wrapper around <code>builtins.path</code> which will automatically set the
path's <code>name</code> to the workspace's package name (or a placeholder value of
<code>"source"</code> if a name cannot be determined).</p>
<p>It should be used anywhere a relative path like <code>./.</code> or <code>./..</code> is needed so
that the result is reproducible and caches can be reused. Otherwise the store
path <a href="https://nix.dev/anti-patterns/language#reproducibility-referencing-top-level-directory-with">will depend on the name of the parent
directory</a> which may cause unnecessary rebuilds.</p>
<pre><code class="language-nix">craneLib.path ./.
# "/nix/store/wbhf6c7wiw9z53hsn487a8wswivwdw81-source"
</code></pre>
<pre><code class="language-nix">craneLib.path ./checks/simple
# "/nix/store/s9scn97c86kqskf7yv5n2k85in5y5cmy-simple"
</code></pre>
<p>It is also possible to use as a drop in replacement for <code>builtins.path</code>:</p>
<pre><code class="language-nix">craneLib.path {
  path = ./.;
  name = "asdf";
}
# "/nix/store/23zy3c68v789cg8sysgba0rbgbfcjfhn-asdf"
</code></pre>
<h3 id="cranelibregistryfromdownloadurl"><a class="header" href="#cranelibregistryfromdownloadurl"><code>craneLib.registryFromDownloadUrl</code></a></h3>
<p><code>registryFromDownloadUrl :: set -&gt; set</code></p>
<p>Prepares a crate registry into a format that can be passed directly to
<code>appendCrateRegistries</code> using the registry's download URL.</p>
<p>If the registry in question has a stable download URL (which either never
changes, or it does so very infrequently), then <code>registryFromDownloadUrl</code> is a
great and lightweight choice for including the registry. To get started, look up
the
<a href="https://github.com/rust-lang/crates.io-index/blob/24ecfa9c82456a79ec115736f1fcefc0be375b52/config.json#L2"><code>config.json</code></a> at the registry's root and copy the value of the <code>dl</code> entry.</p>
<p>If the registry's download endpoint changes more frequently and you would like
to infer the configuration directly from a git revision, consider using
<code>registryFromGitIndex</code> as an alternative.</p>
<p>If the registry needs a special way of accessing crate sources the
<code>fetchurlExtraArgs</code> set can be used to influence the behavior of fetching the
crate sources (e.g. by setting <code>curlOptsList</code>)</p>
<h4 id="required-attributes-9"><a class="header" href="#required-attributes-9">Required attributes</a></h4>
<ul>
<li><code>dl</code>: the value of the <code>dl</code> entry in the registry's <code>config.json</code> file</li>
<li><code>indexUrl</code>: an HTTP URL to the index</li>
</ul>
<h4 id="optional-attributes-19"><a class="header" href="#optional-attributes-19">Optional attributes</a></h4>
<ul>
<li><code>fetchurlExtraArgs</code>: a set of arguments which will be passed on to the
<code>fetchurl</code> for each crate being sourced from this registry</li>
</ul>
<pre><code class="language-nix">craneLib.registryFromDownloadUrl {
  dl = "https://static.crates.io/crates";
  indexUrl = "https://github.com/rust-lang/crates.io-index";
}
# {
#   "registry+https://github.com/rust-lang/crates.io-index" = {
#     downloadUrl = "https://static.crates.io/crates/{crate}/{version}/download";
#     fetchurlExtraArgs = {};
#   };
# }
</code></pre>
<h3 id="cranelibregistryfromgitindex"><a class="header" href="#cranelibregistryfromgitindex"><code>craneLib.registryFromGitIndex</code></a></h3>
<p><code>registryFromGitIndex :: set -&gt; set</code></p>
<p>Prepares a crate registry into a format that can be passed directly to
<code>appendCrateRegistries</code> using a revision of the registry index to infer the
download URL.</p>
<p>Note that the specified git revision <em>does not need to track updates to the
index itself</em> as long as the pinned revision contains the most recent version of
the <code>config.json</code> file. In other words, this commit revision only needs to be
updated if the <code>config.json</code> file changes.</p>
<p>Also note that this approach means that the contents of the entire index at the
specified revision will be added to the Nix store during evaluation time, and
that IFD will need to be enabled. If this is unsatisfactory, consider using
<code>registryFromDownloadUrl</code> as a simpler alternative.</p>
<p>If the registry needs a special way of accessing crate sources the
<code>fetchurlExtraArgs</code> set can be used to influence the behavior of fetching the
crate sources (e.g. by setting <code>curlOptsList</code>)</p>
<h4 id="required-attributes-10"><a class="header" href="#required-attributes-10">Required attributes</a></h4>
<ul>
<li><code>indexUrl</code>: an HTTP URL to the index</li>
<li><code>rev</code>: any git revision which contains the latest <code>config.json</code> definition</li>
</ul>
<h4 id="optional-attributes-20"><a class="header" href="#optional-attributes-20">Optional attributes</a></h4>
<ul>
<li><code>fetchurlExtraArgs</code>: a set of arguments which will be passed on to the
<code>fetchurl</code> for each crate being sourced from this registry</li>
</ul>
<pre><code class="language-nix">craneLib.registryFromGitIndex {
  url = "https://github.com/Hirevo/alexandrie-index";
  rev = "90df25daf291d402d1ded8c32c23d5e1498c6725";
}
# {
#   "registry+https://github.com/Hirevo/alexandrie-index" = {
#     downloadUrl = "https://crates.polomack.eu/api/v1/crates/{crate}/{version}/download";
#     fetchurlExtraArgs = {};
#   };
# }
</code></pre>
<h3 id="cranelibregistryfromsparse"><a class="header" href="#cranelibregistryfromsparse"><code>craneLib.registryFromSparse</code></a></h3>
<p><code>registryFromSparse :: set -&gt; set</code></p>
<p>Prepares a (sparse) crate registry into a format that can be passed directly to
<code>appendCrateRegistries</code> using the registry's download URL.</p>
<p>If the registry in question has a stable download URL (which either never
changes, or it does so very infrequently), then <code>registryFromDownloadUrl</code> is a
great and lightweight choice for including the registry. To get started,
download the registry's <code>config.json</code> and copy the value of the <code>dl</code> entry.</p>
<p>If the registry's download endpoint changes more frequently and you would like
to infer the configuration directly from a git revision, consider using
<code>registryFromGitIndex</code> as an alternative.</p>
<p>If the registry needs a special way of accessing crate sources (such as for
authorization), the <code>fetchurlExtraArgs</code> set can be used to influence the
behavior of fetching the crate sources (e.g. by setting <code>curlOptsList</code>)</p>
<h4 id="required-attributes-11"><a class="header" href="#required-attributes-11">Required attributes</a></h4>
<ul>
<li><code>indexUrl</code>: an HTTP URL to the registry's config.json</li>
<li><code>configSha256</code>: a sha256 hash of the contents of config.json</li>
</ul>
<h4 id="optional-attributes-21"><a class="header" href="#optional-attributes-21">Optional attributes</a></h4>
<ul>
<li><code>fetchurlExtraArgs</code>: a set of arguments which will be passed on to the
<code>fetchurl</code> for each crate being sourced from this registry, and to the
initial query for the registry's <code>config.json</code>.</li>
</ul>
<pre><code class="language-nix">craneLib.registryFromSparse {
  indexUrl = "https://index.crates.io/config.json";
  configSha256 = "1cxgzdm1ipqmgwnq7kgym92axna7pfyhgfla63vl7dvydwn3m52v";
}
# {
#   "sparse+https://index.crates.io/config.json/" = {
#     downloadUrl = "https://static.crates.io/crates/{crate}/{version}/download";
#     fetchurlExtraArgs = { };
#   };
# }
</code></pre>
<h3 id="craneliburlforcargopackage"><a class="header" href="#craneliburlforcargopackage"><code>craneLib.urlForCargoPackage</code></a></h3>
<p><code>urlForCargoPackage :: set -&gt; set</code></p>
<p>Returns info pertaining to the URL for downloading a particular crate if the
crate's registry is configured (an error will be thrown if it is not).</p>
<p>The result will contain two attributes:</p>
<ul>
<li><code>url</code>: A string representing the URL at which the crate can be fetched</li>
<li><code>fetchurlExtraArgs</code>: A set of attributes specific to this registry which will
be passed on to the <code>fetchurl</code> invocation.</li>
</ul>
<h4 id="required-input-attributes-2"><a class="header" href="#required-input-attributes-2">Required input attributes</a></h4>
<ul>
<li><code>name</code>: the name of the crate</li>
<li><code>source</code>: the source key recorded in the Cargo.lock file</li>
<li><code>version</code>: the version of the crate</li>
</ul>
<h3 id="cranelibvendorcargodeps"><a class="header" href="#cranelibvendorcargodeps"><code>craneLib.vendorCargoDeps</code></a></h3>
<p><code>vendorCargoDeps :: set -&gt; drv</code></p>
<p>Creates a derivation which will download all crates referenced by a Cargo.lock
file, and prepare a vendored directory which cargo can use for subsequent builds
without needing network access.</p>
<p>Each unique crate index will be vendored as its own subdirectory within the
output of the derivation. A <code>config.toml</code> file will also be placed at the root
of the output which will contain the necessary configurations to point cargo to
the vendored directories (i.e. this configuration can be appended to the
<code>.cargo/config.toml</code> definition of the project).</p>
<h4 id="input-attributes-2"><a class="header" href="#input-attributes-2">Input attributes</a></h4>
<ul>
<li><code>src</code>: a directory which includes a Cargo.lock file at its root.</li>
<li><code>cargoLock</code>: a path to a Cargo.lock file</li>
<li><code>cargoLockContents</code>: the contents of a Cargo.lock file as a string</li>
<li><code>cargoLockParsed</code>: the parsed contents of Cargo.lock as an attribute set</li>
</ul>
<p>At least one of the above attributes must be specified, or an error will be
raised during evaluation.</p>
<h4 id="optional-attributes-22"><a class="header" href="#optional-attributes-22">Optional attributes</a></h4>
<ul>
<li><code>outputHashes</code>: a mapping of package-source to the <code>hash</code> attribute of the
(unpacked) download. Useful for supporting fully offline evaluations.
<ul>
<li>Default value: <code>[]</code></li>
</ul>
</li>
<li><code>overrideVendorCargoPackage</code>: a function that will be called on every crate
vendored from a cargo registry, which allows for modifying the derivation
which will unpack the cargo tarball (e.g. to patch the crate source).
It will be called with the following parameters:
<ol>
<li>The <code>Cargo.lock</code> entry for that package (to allow conditional overrides
based on the package name/version/source, etc.)</li>
<li>The default <code>downloadCargoPackage</code> derivation</li>
</ol>
<ul>
<li>Default value: <code>_p: drv: drv</code></li>
</ul>
</li>
<li><code>overrideVendorGitCheckout</code>: a function that will be called on every unique
checkout vendored from a git repository, which allows for modifying the
derivation which will unpack the cargo crates found in the checkout (e.g. to
patch the crate sources). It will be called with the following
parameters:
<ol>
<li>A list of the <code>Cargo.lock</code> entries for each package which shares the same
repo URL and revision to checkout (to allow conditional overrides based on
the repo/checkout etc.)</li>
<li>The default <code>downloadCargoPackageFromGit</code> derivation</li>
</ol>
<ul>
<li>Default value: <code>_ps: drv: drv</code></li>
</ul>
</li>
</ul>
<h3 id="cranelibvendorcargoregistries"><a class="header" href="#cranelibvendorcargoregistries"><code>craneLib.vendorCargoRegistries</code></a></h3>
<p><code>vendorCargoRegistries :: set -&gt; set</code></p>
<p>Creates the derivations necessary to download all crates from all registries
referenced by a <code>Cargo.lock</code> file, and prepare the vendored directories which
cargo can use for subsequent builds without needing network access.</p>
<h4 id="input-attributes-3"><a class="header" href="#input-attributes-3">Input attributes</a></h4>
<ul>
<li><code>lockPackages</code>: a list of all <code>[[package]]</code> entries found in the project's
<code>Cargo.lock</code> file (parsed via <code>builtins.fromTOML</code>)</li>
</ul>
<h4 id="optional-attributes-23"><a class="header" href="#optional-attributes-23">Optional attributes</a></h4>
<ul>
<li><code>cargoConfigs</code>: a list of paths to all <code>.cargo/config.toml</code> files which may
appear in the project. Ignored if <code>registries</code> is set.
<ul>
<li>Default value: <code>[]</code></li>
</ul>
</li>
<li><code>overrideVendorCargoPackage</code>: a function that will be called on every crate
vendored from a cargo registry, which allows for modifying the derivation
which will unpack the cargo tarball (e.g. to patch the crate source).
It will be called with the following parameters:
<ol>
<li>The <code>Cargo.lock</code> entry for that package (to allow conditional overrides
based on the package name/version/source, etc.)</li>
<li>The default <code>downloadCargoPackage</code> derivation</li>
</ol>
<ul>
<li>Default value: <code>_p: drv: drv</code></li>
</ul>
</li>
<li><code>registries</code>: an attrset of registry names to their index URL. The default
("crates-io") registry need not be specified, as it will automatically be
available, but it can be overridden if required.
<ul>
<li>Default value: if not specified, <code>cargoConfigs</code> will be used to identify any
configured registries</li>
</ul>
</li>
</ul>
<h4 id="output-attributes-1"><a class="header" href="#output-attributes-1">Output attributes</a></h4>
<ul>
<li><code>config</code>: the configuration entires needed to point cargo to the vendored
crates. This is intended to be appended to <code>$CARGO_HOME/config.toml</code> verbatim</li>
<li><code>sources</code>: an attribute set of all the newly created cargo sources' names to
their location in the Nix store</li>
</ul>
<h3 id="cranelibvendorgitdeps"><a class="header" href="#cranelibvendorgitdeps"><code>craneLib.vendorGitDeps</code></a></h3>
<p><code>vendorGitDeps :: set -&gt; set</code></p>
<p>Creates the derivations necessary to download all crates from all git
dependencies referenced by a <code>Cargo.lock</code> file, and prepare the vendored
directories which cargo can use for subsequent builds without needing network
access.</p>
<h4 id="input-attributes-4"><a class="header" href="#input-attributes-4">Input attributes</a></h4>
<ul>
<li><code>lockPackages</code>: a list of all <code>[[package]]</code> entries found in the project's
<code>Cargo.lock</code> file (parsed via <code>builtins.fromTOML</code>)</li>
</ul>
<h4 id="optional-attributes-24"><a class="header" href="#optional-attributes-24">Optional attributes</a></h4>
<ul>
<li><code>outputHashes</code>: a mapping of package-source to the <code>hash</code> attribute of the
(unpacked) download. Useful for supporting fully offline evaluations.
<ul>
<li>Default value: <code>[]</code></li>
</ul>
</li>
<li><code>overrideVendorGitCheckout</code>: a function that will be called on every unique
checkout vendored from a git repository, which allows for modifying the
derivation which will unpack the cargo crates found in the checkout (e.g. to
patch the crate sources). It will be called with the following
parameters:
<ol>
<li>A list of the <code>Cargo.lock</code> entries for each package which shares the same
repo URL and revision to checkout (to allow conditional overrides based on
the repo/checkout etc.)</li>
<li>The default <code>downloadCargoPackageFromGit</code> derivation</li>
</ol>
<ul>
<li>Default value: <code>_ps: drv: drv</code></li>
</ul>
</li>
</ul>
<h4 id="output-attributes-2"><a class="header" href="#output-attributes-2">Output attributes</a></h4>
<ul>
<li><code>config</code>: the configuration entires needed to point cargo to the vendored
sources. This is intended to be appended to <code>$CARGO_HOME/config.toml</code> verbatim</li>
<li><code>sources</code>: an attribute set of all the newly created cargo sources' names to
their location in the Nix store</li>
</ul>
<h3 id="cranelibvendormultiplecargodeps"><a class="header" href="#cranelibvendormultiplecargodeps"><code>craneLib.vendorMultipleCargoDeps</code></a></h3>
<p><code>vendorMultipleCargoDeps :: set -&gt; drv</code></p>
<p>Creates a derivation which will download all crates referenced by several
<code>Cargo.lock</code> files, and prepare a vendored directory which cargo can use for
subsequent builds without needing network access. Duplicate packages listed in
different <code>Cargo.lock</code> files will automatically be filtered out.</p>
<p>Each unique crate index will be vendored as its own subdirectory within the
output of the derivation. A <code>config.toml</code> file will also be placed at the root
of the output which will contain the necessary configurations to point cargo to
the vendored directories (i.e. this configuration can be appended to the
<code>.cargo/config.toml</code> definition of the project).</p>
<h4 id="optional-attributes-25"><a class="header" href="#optional-attributes-25">Optional attributes</a></h4>
<ul>
<li><code>cargoConfigs</code>: a list of paths to all <code>.cargo/config.toml</code> files which may
appear in the project. Ignored if <code>registries</code> is set.
<ul>
<li>Default value: <code>[]</code></li>
</ul>
</li>
<li><code>cargoLockContentsList</code>: a list of strings representing the contents of
different <code>Cargo.lock</code> files to be included while vendoring. The strings will
automatically be parsed during evaluation.
<ul>
<li>Default value: <code>[]</code></li>
</ul>
</li>
<li><code>cargoLockList</code>: a list of paths to different <code>Cargo.lock</code> files to be
included while vendoring. The paths will automatically be read and parsed
during evaluation.
<ul>
<li>Default value: <code>[]</code></li>
</ul>
</li>
<li><code>cargoLockParsedList</code>: a list of attrsets representing the parsed contents of
different <code>Cargo.lock</code> files to be included while vendoring.
<ul>
<li>Default value: <code>[]</code></li>
</ul>
</li>
<li><code>outputHashes</code>: a mapping of package-source to the <code>hash</code> attribute of the
(unpacked) download. Useful for supporting fully offline evaluations.
<ul>
<li>Default value: <code>[]</code></li>
</ul>
</li>
<li><code>overrideVendorCargoPackage</code>: a function that will be called on every crate
vendored from a cargo registry, which allows for modifying the derivation
which will unpack the cargo tarball (e.g. to patch the crate source).
It will be called with the following parameters:
<ol>
<li>The <code>Cargo.lock</code> entry for that package (to allow conditional overrides
based on the package name/version/source, etc.)</li>
<li>The default <code>downloadCargoPackage</code> derivation</li>
</ol>
<ul>
<li>Default value: <code>_p: drv: drv</code></li>
</ul>
</li>
<li><code>overrideVendorGitCheckout</code>: a function that will be called on every unique
checkout vendored from a git repository, which allows for modifying the
derivation which will unpack the cargo crates found in the checkout (e.g. to
patch the crate sources). It will be called with the following
parameters:
<ol>
<li>A list of the <code>Cargo.lock</code> entries for each package which shares the same
repo URL and revision to checkout (to allow conditional overrides based on
the repo/checkout etc.)</li>
<li>The default <code>downloadCargoPackageFromGit</code> derivation</li>
</ol>
<ul>
<li>Default value: <code>_ps: drv: drv</code></li>
</ul>
</li>
<li><code>registries</code>: an attrset of registry names to their index URL. The default
("crates-io") registry need not be specified, as it will automatically be
available, but it can be overridden if required.
<ul>
<li>Default value: if not specified, <code>cargoConfigs</code> will be used to identify any
configured registries</li>
</ul>
</li>
</ul>
<h3 id="cranelibwritetoml"><a class="header" href="#cranelibwritetoml"><code>craneLib.writeTOML</code></a></h3>
<p><code>writeTOML :: String -&gt; String -&gt; drv</code></p>
<p>Takes a file name and an attribute set, converts the set to a TOML document and
writes it to a file with the given name.</p>
<pre><code class="language-nix">craneLib.writeTOML "foo.toml" { foo.bar = "baz"; }
# «derivation /nix/store/...-foo.toml.drv»
</code></pre>
<h2 id="hooks"><a class="header" href="#hooks">Hooks</a></h2>
<h3 id="cranelibcargohelperfunctionshook"><a class="header" href="#cranelibcargohelperfunctionshook"><code>craneLib.cargoHelperFunctionsHook</code></a></h3>
<p>Defines helper functions for internal use. It is probably not a great idea to
depend on these directly as their behavior can change at any time, but it is
worth documenting them just in case:</p>
<ul>
<li>Defines a <code>cargo()</code> function which will immediately invoke the <code>cargo</code> command
found on the <code>$PATH</code> after echoing the exact arguments that were passed in.
Useful for automatically logging all cargo invocations to the log.</li>
<li>Defines a <code>cargoWithProfile()</code> function which will invoke <code>cargo</code> with the
provided arguments. If <code>$CARGO_PROFILE</code> is set, then <code>--profile $CARGO_PROFILE</code> will be injected into the <code>cargo</code> invocation
<ul>
<li>Note: a default value of <code>$CARGO_PROFILE</code> is set via
<code>configureCargoCommonVarsHook</code>. You can set <code>CARGO_PROFILE = "something"</code> in
your derivation to change which profile is used, or set <code>CARGO_PROFILE = "";</code> to omit it altogether.</li>
</ul>
</li>
</ul>
<h3 id="cranelibconfigurecargocommonvarshook"><a class="header" href="#cranelibconfigurecargocommonvarshook"><code>craneLib.configureCargoCommonVarsHook</code></a></h3>
<p>Defines <code>configureCargoCommonVars()</code> which will set various common cargo-related
variables, such as honoring the amount of parallelism dictated by Nix, disabling
incremental artifacts, etc. More specifically:</p>
<ul>
<li><code>CARGO_BUILD_INCREMENTAL</code> is set to <code>false</code> if not already defined</li>
<li><code>CARGO_BUILD_JOBS</code> is set to <code>$NIX_BUILD_CORES</code> if not already defined</li>
<li><code>CARGO_HOME</code> is set to <code>$PWD/.cargo-home</code> if not already defined.
<ul>
<li>The directory that <code>CARGO_HOME</code> points to will be created</li>
</ul>
</li>
<li><code>CARGO_PROFILE</code> is set to <code>release</code> if not already defined.
<ul>
<li>Note that this is is used internally specify a cargo profile (e.g. <code>cargo build --profile release</code>) and not something natively understood by cargo.</li>
</ul>
</li>
<li><code>RUST_TEST_THREADS</code> is set to <code>$NIX_BUILD_CORES</code> if not already defined</li>
</ul>
<p><strong>Automatic behavior:</strong> runs as a post-patch hook</p>
<h3 id="cranelibconfigurecargovendoreddepshook"><a class="header" href="#cranelibconfigurecargovendoreddepshook"><code>craneLib.configureCargoVendoredDepsHook</code></a></h3>
<p>Defines <code>configureCargoVendoredDeps()</code> which will prepare cargo to use a
directory of vendored crate sources. It takes two positional arguments:</p>
<ol>
<li>a path to the vendored sources
<ul>
<li>If not specified, the value of <code>$cargoVendorDir</code> will be used</li>
<li>If <code>cargoVendorDir</code> is not specified, an error will be raised</li>
</ul>
</li>
<li>a path to a cargo config file to modify
<ul>
<li>If not specified, the value of <code>$CARGO_HOME/config.toml</code> will be used</li>
<li>This cargo config file will be appended with a stanza which will instruct
cargo to use the vendored sources (instead of downloading the sources
directly) as follows:
<ul>
<li>If the vendored directory path contains a file named <code>config.toml</code>,
then its contents will be appended to the specified cargo config path.</li>
<li>Otherwise the entire vendored directory path will be treated as if it
only vendors the crates.io index and will be configured as such.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>Automatic behavior:</strong> if <code>cargoVendorDir</code> is set, then
<code>configureCargoVendoredDeps "$cargoVendorDir" "$CARGO_HOME/config.toml"</code> will be
run as a pre configure hook.</p>
<h3 id="cranelibcranelib"><a class="header" href="#cranelibcranelib"><code>craneLib.craneLib</code></a></h3>
<p>A self-reference to the crane lib instance.</p>
<h3 id="cranelibinheritcargoartifactshook"><a class="header" href="#cranelibinheritcargoartifactshook"><code>craneLib.inheritCargoArtifactsHook</code></a></h3>
<p>Defines <code>inheritCargoArtifacts()</code> which will pre-populate cargo's artifact
directory using a previous derivation. It takes two positional arguments:</p>
<ol>
<li>a path to the previously prepared artifacts
<ul>
<li>If not specified, the value of <code>$cargoArtifacts</code> will be used</li>
<li>If <code>cargoArtifacts</code> is not specified, an error will be raised</li>
<li>If the specified path is a directory which contains a file called
<code>target.tar.zst</code>, then that file will be used as specified below</li>
<li>If the specified path is a file (and not a directory) it is assumed that it
contains a zstd compressed tarball and will be decompressed and unpacked
into the specified cargo artifacts directory</li>
<li>If the specified path is a directory which contains another directory
called <code>target</code>, then that directory will be used as specified below</li>
<li>If the specified path is a directory, its contents will be copied into the
specified cargo artifacts directory</li>
<li>The previously prepared artifacts are expected to be a zstd compressed
tarball</li>
</ul>
</li>
<li>the path to cargo's artifact directory, where the previously prepared
artifacts should be unpacked
<ul>
<li>If not specified, the value of <code>$CARGO_TARGET_DIR</code> will be used</li>
<li>If <code>CARGO_TARGET_DIR</code> is not set, cargo's default target location  (i.e.
<code>./target</code>) will be used.</li>
</ul>
</li>
</ol>
<p>Note that as an optimization, some dependency artifacts will be symlinked
instead of (deeply) copied to <code>$CARGO_TARGET_DIR</code>. To disable this behavior set
<code>doNotLinkInheritedArtifacts</code>, and all artifacts will be copied as plain,
writable files.</p>
<p><strong>Automatic behavior:</strong> if <code>cargoArtifacts</code> is set, then
<code>inheritCargoArtifacts "$cargoArtifacts" "$CARGO_TARGET_DIR"</code> will be run as a
post patch hook.</p>
<p><strong>Required nativeBuildInputs</strong>: assumes <code>zstd</code> is available on the <code>$PATH</code></p>
<h3 id="cranelibinstallcargoartifactshook"><a class="header" href="#cranelibinstallcargoartifactshook"><code>craneLib.installCargoArtifactsHook</code></a></h3>
<p>Defines <code>compressAndInstallCargoArtifactsDir()</code> which handles installing
cargo's artifact directory to the derivation's output as a zstd compressed
tarball. It takes two positional arguments:</p>
<ol>
<li>the installation directory for the output.
<ul>
<li>An error will be raised if not specified</li>
<li>Cargo's artifact directory will be compressed as a reproducible tarball
with zstd compression. It will be written to this directory and named
<code>target.tar.zstd</code></li>
</ul>
</li>
<li>the path to cargo's artifact directory
<ul>
<li>An error will be raised if not specified</li>
</ul>
</li>
</ol>
<p>If <code>$zstdCompressionExtraArgs</code> is set, <code>compressAndInstallCargoArtifactsDir()</code>
will pass its contents along to <code>zstd</code> when compressing artifacts.</p>
<p>Defines <code>dedupAndInstallCargoArtifactsDir()</code> which handles installing
cargo's artifact directory to the derivation's output after deduplicating
identical files against a directory of previously prepared cargo artifacts.
It takes three positional arguments:</p>
<ol>
<li>the installation directory for the output.
<ul>
<li>An error will be raised if not specified</li>
<li>If the specified path is a directory which exists then the current cargo
artifacts will be compared with the contents of said directory. Any files
whose contents and paths match will be symbolically linked together to
reduce the size of the data stored in the Nix store.</li>
</ul>
</li>
<li>the path to cargo's artifact directory
<ul>
<li>An error will be raised if not specified</li>
</ul>
</li>
<li>a path to the previously prepared cargo artifacts
<ul>
<li>An error will be raised if not specified</li>
<li><code>/dev/null</code> can be specified here if there is no previous directory to
deduplicate against</li>
</ul>
</li>
</ol>
<p>Defines <code>prepareAndInstallCargoArtifactsDir()</code> which handles installing cargo's
artifact directory to the derivation's output. It takes three positional
arguments:</p>
<ol>
<li>the installation directory for the output.
<ul>
<li>If not specified, the value of <code>$out</code> will be used</li>
<li>Cargo's artifact directory will be installed based on the installation mode
selected below</li>
</ul>
</li>
<li>the path to cargo's artifact directory
<ul>
<li>If not specified, the value of <code>$CARGO_TARGET_DIR</code> will be used</li>
<li>If <code>CARGO_TARGET_DIR</code> is not set, cargo's default target location  (i.e.
<code>./target</code>) will be used.</li>
</ul>
</li>
<li>the installation mode to apply
<ul>
<li>If specified, the value of <code>$installCargoArtifactsMode</code> will be used,
otherwise, a default value of <code>"use-zstd"</code> will be used</li>
<li>If set to "use-symlink" then <code>dedupAndInstallCargoArtifactsDir()</code> will be
used.
<ul>
<li>If <code>$cargoArtifacts</code> is defined and <code>$cargoArtifacts/target</code> is a valid
directory, it will be used during file deduplication</li>
</ul>
</li>
<li>If set to "use-zstd" then <code>compressAndInstallCargoArtifactsDir()</code> will be
used.</li>
<li>Otherwise an error will be raised if the mode is not recognized</li>
</ul>
</li>
</ol>
<p><strong>Automatic behavior:</strong> if <code>doInstallCargoArtifacts</code> is set to <code>1</code>, then
<code>prepareAndInstallCargoArtifactsDir "$out" "$CARGO_TARGET_DIR"</code> will be run as a
post install hook.</p>
<p><strong>Required nativeBuildInputs</strong>: assumes <code>zstd</code> is available on the <code>$PATH</code></p>
<h3 id="cranelibinstallfromcargobuildloghook"><a class="header" href="#cranelibinstallfromcargobuildloghook"><code>craneLib.installFromCargoBuildLogHook</code></a></h3>
<p>Defines <code>installFromCargoBuildLog()</code> which will use a build log produced by
cargo to find and install any binaries and libraries which have been built. It
takes two positional arguments:</p>
<ol>
<li>a path to where artifacts should be installed
<ul>
<li>If not specified, the value of <code>$out</code> will be used</li>
<li>Binaries will be installed in a <code>bin</code> subdirectory</li>
<li>Libraries will be installed in a <code>lib</code> subdirectory
<ul>
<li>Note that only library targets with the <code>staticlib</code> and <code>cdylib</code>
crate-types will be installed. Library targets with the <code>rlib</code> crate-type
will be ignored</li>
</ul>
</li>
</ul>
</li>
<li>a path to a JSON formatted build log written by cargo
<ul>
<li>If not specified, the value of <code>$cargoBuildLog</code> will be used</li>
<li>If <code>cargoBuildLog</code> is not set, an error will be raised</li>
<li>This log can be captured, for example, via <code>cargo build --message-format json-render-diagnostics &gt;cargo-build.json</code></li>
</ul>
</li>
</ol>
<p>Defines <code>postBuildInstallFromCargoBuildLog()</code> which will use a build log produced by
cargo to find and install any binaries and libraries which have been built into
a temporary location defined by <code>$postBuildInstallFromCargoBuildLogOut</code></p>
<p><strong>Automatic behavior:</strong> if <code>doNotPostBuildInstallCargoBinaries</code> is not set, then
<code>$postBuildInstallFromCargoBuildLogOut</code> will be set to a temporary directory and
<code>postBuildInstallFromCargoBuildLog</code> will be run as a post build hook.</p>
<p><strong>Required nativeBuildInputs</strong>: assumes <code>cargo</code> is available on the <code>$PATH</code></p>
<h3 id="cranelibremovereferencestorusttoolchainhook"><a class="header" href="#cranelibremovereferencestorusttoolchainhook"><code>craneLib.removeReferencesToRustToolchainHook</code></a></h3>
<p>Defines <code>removeReferencesToRustToolchain()</code> which handles removing all
references to the Rust toolchain from the installed binaries, ensuring that the final
binaries do not have a (false) runtime dependency on the toolchain (usually due to
references in panic messages). The current toolchain is detected via <code>rustc --print sysroot</code>.
It takes 1 positional argument:</p>
<ol>
<li>the installation directory for the output.</li>
</ol>
<ul>
<li>If not specified, the value  of <code>$out</code> will be used.</li>
<li>If <code>out</code> is not specified, an error will be raised.</li>
</ul>
<p><strong>Automatic behavior:</strong> if <code>doNotRemoveReferencesToRustToolchain</code> is not set,
then <code>removeReferencesToRustToolchain "$out"</code> will be run as a post install
hook.</p>
<p><strong>Required nativeBuildInputs</strong>: assumes <code>rustc</code> is available on the <code>$PATH</code></p>
<h3 id="cranelibremovereferencestovendoredsourceshook"><a class="header" href="#cranelibremovereferencestovendoredsourceshook"><code>craneLib.removeReferencesToVendoredSourcesHook</code></a></h3>
<p>Defines <code>removeReferencesToVendoredSources()</code> which handles removing all
references to vendored sources from the installed binaries, which ensures that
nix does not consider the binaries as having a (runtime) dependency on the
sources themselves. It takes two positional arguments:</p>
<ol>
<li>the installation directory for the output.
<ul>
<li>If not specified, the value of <code>$out</code> will be used</li>
<li>If <code>out</code> is not specified, an error will be raised</li>
</ul>
</li>
<li>a path to the vendored sources
<ul>
<li>If not specified, the value of <code>$cargoVendorDir</code> will be used</li>
<li>If <code>cargoVendorDir</code> is not specified, an error will be raised</li>
<li>Note: it is expected that this directory has the exact structure as would
be produced by <code>craneLib.vendorCargoDeps</code></li>
</ul>
</li>
</ol>
<p>Any patched binaries on <code>aarch64-darwin</code> will be <a href="https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/Introduction/Introduction.html">signed</a>. You can disable this functionality by setting <code>doNotSign</code>.</p>
<p><strong>Automatic behavior:</strong> if <code>cargoVendorDir</code> is set and
<code>doNotRemoveReferencesToVendorDir</code> is not set, then
<code>removeReferencesToVendoredSources "$out" "$cargoVendorDir"</code> will be run as a
post install hook.</p>
<h3 id="cranelibreplacecargolockhook"><a class="header" href="#cranelibreplacecargolockhook"><code>craneLib.replaceCargoLockHook</code></a></h3>
<p>Defines <code>replaceCargoLock()</code> which handles replacing or inserting a specified
<code>Cargo.lock</code> file in the current directory. It takes one positional argument:</p>
<ol>
<li>a file which will be copied to <code>Cargo.lock</code> in the current directory
<ul>
<li>If not specified, the value of <code>$cargoLock</code> will be used</li>
<li>If <code>$cargoLock</code> is not set, an error will be raised</li>
</ul>
</li>
</ol>
<p><strong>Automatic behavior:</strong> if <code>cargoLock</code> is set and
<code>doNotReplaceCargoLock</code> is not set, then <code>replaceCargoLock "$cargoLock"</code> will be
run as a pre patch hook.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="troubleshooting-and-frequently-asked-questions"><a class="header" href="#troubleshooting-and-frequently-asked-questions">Troubleshooting and Frequently Asked Questions</a></h2>
<p>This chapter captures a list of common questions or issues and how to resolve
them. If you happen to run into an issue that is not documented here, please
consider submitting a pull request!</p>
<div style="break-before: page; page-break-before: always;"></div><p>The crane library can be instantiated with a specific version of nixpkgs as
follows. For more information, see the <a href="faq/../API.html">API docs</a> for <code>mkLib</code>.</p>
<pre><code class="language-nix"># Instantiating for a specific `system`
crane.mkLib (import nixpkgs {
  system = "armv7l-linux";
})
</code></pre>
<pre><code class="language-nix"># Instantiating for cross compiling
crane.mkLib (import nixpkgs {
  localSystem = "x86_64-linux";
  crossSystem = "aarch64-linux";
})
</code></pre>
<p>The crane library can also be instantiated with a particular rust toolchain:</p>
<pre><code class="language-nix"># For example, using rust-overlay
let
  system = "x86_64-linux";
  pkgs = import nixpkgs {
    inherit system;
    overlays = [ (import rust-overlay) ];
  };
in
(crane.mkLib pkgs).overrideToolchain (p: p.rust-bin.stable.latest.default.override {
    targets = [ "wasm32-wasi" ];
})
</code></pre>
<p>Finally, specific inputs can be overridden for the entire library via the
<code>overrideScope</code> API as follows. For more information, see the <a href="faq/../API.html">API
docs</a> for <code>mkLib</code>/<code>overrideToolchain</code>, or checkout the
<a href="faq/../../examples/custom-toolchain">custom-toolchain</a> example.</p>
<pre><code class="language-nix">(crane.mkLib pkgs).overrideScope (final: prev: {
  cargo-tarpaulin = myCustomCargoTarpaulinVersion;
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nix-is-complaining-about-ifd-import-from-derivation"><a class="header" href="#nix-is-complaining-about-ifd-import-from-derivation">Nix is complaining about IFD (import from derivation)</a></h2>
<p>If a derivation's <code>pname</code> and <code>version</code> attributes are not explicitly set,
crane will inspect the project's <code>Cargo.toml</code> file to set them as a convenience
to avoid duplicating that information by hand. This works well when the source
is a local path, but can cause issues if the source is being fetched remotely,
or flakes are not being used (since flakes have IFD enabled on by default).</p>
<p>One easy workaround for this issue (besides enabling the
<code>allow-import-from-derivation</code> option in Nix) is to explicitly set
<code>{ pname = "..."; version = "..."; }</code> in the derivation.</p>
<p>You'll know you've run into this issue if you see error messages along the lines
of:</p>
<ul>
<li><code>cannot build '/nix/store/...-source.drv' during evaluation because the option 'allow-import-from-derivation' is disabled</code></li>
<li><code>a 'aarch64-darwin' with features {} is required to build '/nix/store/...', but I am a 'x86_64-linux' with features {}</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="im-getting-rebuilds-all-of-the-time-especially-when-i-change-flakenix"><a class="header" href="#im-getting-rebuilds-all-of-the-time-especially-when-i-change-flakenix">I'm getting rebuilds all of the time, especially when I change <code>flake.nix</code></a></h2>
<p>Nix will rebuild a derivation if any of its inputs change, which includes any
file contained by the source that is passed in. For example, if the build
expression specifies <code>src = ./.;</code> then the crate will be rebuilt when <em>any</em> file
changes (including "unrelated" changes to <code>flake.nix</code>)!</p>
<p>There are two main ways to avoid unnecessary builds:</p>
<ol>
<li>Use a <a href="https://nixos.org/manual/nixpkgs/unstable/#sec-functions-library-sources">source cleaning</a> function which can omit any files know to not be
needed while building the crate (for example, all <code>*.nix</code> sources,
<code>flake.lock</code>, and so on). For example <code>cleanCargoSource</code> (see [API docs] for
details) implements some good defaults for ignoring irrelevant files which
are not needed by cargo.</li>
<li>Another option is to put the crate's source files into its own subdirectory
(e.g. <code>./mycrate</code>) and then set the build expression's source to that
subdirectory (e.g. <code>src = ./mycrate;</code>). Then, changes to files <em>outside</em> of
that directory will be ignored and will not cause a rebuild</li>
</ol>
<p>In certain (especially non-trivial) crane-based workflows, it's possible that
a change to a given file might trigger rebuilds of certain seemingly unrelated derivations.
This is most often caused by a subtle bug introducing undesired derivation inputs.</p>
<h3 id="debugging-with-nix-diff"><a class="header" href="#debugging-with-nix-diff">Debugging with nix-diff</a></h3>
<p>An efficient way to debug such problems is to use <a href="https://github.com/Gabriella439/nix-diff"><code>nix-diff</code></a> to compare the derivation build plans:</p>
<pre><code class="language-sh"># nix-diff does not support direct flake-urls so we'll need
# to get the actual derivation name
nix show-derivation .#affectedOutput | nix run nixpkgs#jq -- -r 'keys[0]' &gt; before_drv
echo &gt;&gt; ./file/triggering/rebuild # cause a rebuild
nix show-derivation .#affectedOutput | nix run nixpkgs#jq -- -r 'keys[0]' &gt; after_drv
nix run nixpkgs#nix-diff "$(cat before_drv)" "$(cat after_drv)"
</code></pre>
<h3 id="debugging-with-just-nix"><a class="header" href="#debugging-with-just-nix">Debugging with just <code>nix</code></a></h3>
<p>Another way to debug such problems is to use <code>nix derivation show -r</code> to compare the derivation build plans:</p>
<pre><code class="language-sh">nix derivation show -r .#affectedOutput &gt; before
echo &gt;&gt; ./file/triggering/rebuild # cause a rebuild
nix derivation show -r .#affectedOutput &gt; after
diff -u before after
</code></pre>
<p>The difference in the highest-level derivation should point to a direct cause of the rebuild (possibly a different lower-level input derivation which can be compared recursively).</p>
<h2 id="ive-used-a-source-filter-but-cargo-is-still-rebuilding-all-dependencies-from-scratch"><a class="header" href="#ive-used-a-source-filter-but-cargo-is-still-rebuilding-all-dependencies-from-scratch">I've used a source filter but cargo is still rebuilding all dependencies from scratch!</a></h2>
<p>Another source of artifact invalidation is if</p>
<ul>
<li>A different set of dependency crates are being built between derivations</li>
</ul>
<pre><code class="language-nix">let
  src = ...;
in
craneLib.buildPackage {
  inherit src;

  cargoArtifacts = craneLib.buildDepsOnly {
    inherit src;
    cargoExtraArgs = "-p foo"; # Only build the `foo` crate
  };

  # Oops, we're only building the `bar` crate now
  # any dependency crates used by `bar` but not by `foo`
  # will get built from scratch!
  cargoExtraArgs = "-p bar";
}
</code></pre>
<ul>
<li>Another reason could be using different feature flags between derivations,
which result in setting <em>different</em> feature flags for dependency crates
themselves and causing a rebuild</li>
</ul>
<pre><code class="language-nix">let
  src = ...;
in
craneLib.buildPackage {
  inherit src;

  cargoArtifacts = craneLib.buildDepsOnly {
    inherit src;
    cargoExtraArgs = "--no-default-features"; # Don't use any workspace features
  };

  # Oops, we're now building with an additional downstream feature flag which
  # needs to build more crates which we do not have cached!
  cargoExtraArgs = "--features feature-which-enables-downstream-feature";
}
</code></pre>
<p>If in doubt, double check that the same set of <code>-p</code>/<code>--package</code> and
<code>--features</code>/<code>--no-default-features</code>/<code>--all-features</code> flags are used between all
<code>buildDepsOnly</code>/<code>cargoBuild</code>/<code>cargoClippy</code>/<code>buildPackage</code> derivations.</p>
<h3 id="mixing-package-and-workspace-definitions-in-the-top-level-cargotoml"><a class="header" href="#mixing-package-and-workspace-definitions-in-the-top-level-cargotoml">Mixing <code>[package]</code> and <code>[workspace]</code> definitions in the top-level <code>Cargo.toml</code></a></h3>
<p>Another potential pitfall is defining both <code>[package]</code> and <code>[workspace]</code> in the
project's top-level <code>Cargo.toml</code> file. Although cargo allows <em>both</em> to be
defined, doing so results in cargo only operating on that package by default
(unless the <code>--workspace</code> flag is passed in).</p>
<p>Any subsequent derivations which attempt to build with <code>-p another-crate</code> might
not have their dependencies fully cached. Our recommendation is to only define
<code>[package]</code> in the top-level <code>Cargo.toml</code> if the workspace contains a single
crate; otherwise only <code>[workspace]</code> should be defined.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dependencies-being-rebuilt-even-with-proper-source-filtering-applied"><a class="header" href="#dependencies-being-rebuilt-even-with-proper-source-filtering-applied">Dependencies being rebuilt even with proper source filtering applied</a></h2>
<p>If the dependency crates are being rebuilt even after proper source filtering
has been applied (i.e. the <code>crate-depsOnly</code> derivation is NOT being rebuilt)
check that the same Rust/Cargo toolchain is being used when building artifacts
and vendoring crate sources.</p>
<p>The crate artifacts can only be used for the same compiler version, so if cargo
sees artifacts for the wrong toolchain it will rebuild everything from scratch.</p>
<p>Note that each instance of <code>crane</code> tied to a single Rust toolchain (by default
the one available in <code>nixpkgs</code>, but this can be overridden by the caller). If
you are using multiple <code>craneLib</code> instantiations and you see this occurring,
double check that they aren't being created with a different toolchain
(especially if cross-compilation is being used for the project).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="constantly-rebuilding-proc-macro-dependencies-dev-mode"><a class="header" href="#constantly-rebuilding-proc-macro-dependencies-dev-mode">Constantly rebuilding proc-macro dependencies <code>dev</code> mode</a></h2>
<p>A regression was introduced sometime around Rust 1.71.1 which <a href="https://github.com/rust-lang/cargo/issues/12457">changed how
debuginfo flags are passed to proc-macro crates when using a <code>dev</code>
profile</a>.</p>
<p>If you are building with a <code>dev</code> profile (i.e. <em>not</em> using <code>release</code> builds),
you may want to set the following in <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[profile.dev.build-override]
debug = false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="i-see-the-pyo3-crate-constantly-rebuilding"><a class="header" href="#i-see-the-pyo3-crate-constantly-rebuilding">I see the <code>pyo3</code> crate constantly rebuilding</a></h2>
<p>The <code>pyo3</code> crate uses checks <code>$PYO3_PYTHON</code> for a path to the <code>python</code> binary it
should use during the build. If this environment variable is not set, <code>pyo3</code>
will look for whatever version of <code>python</code> is on the <code>$PATH</code>, which
unfortunately results in the crate being rebuilt when <code>$PATH</code> changes (i.e.
whenever the cargo artifacts are used in a derivation which may have different
build inputs).</p>
<p>The way to remedy this is to explicitly set <code>PYO3_PYTHON</code> to point to the
version of <code>python</code> that will be used by the derivation:</p>
<pre><code class="language-nix">let
  chosenPython = pkgs.python3;
in
craneLib.buildPackage {
  env.PYO3_PYTHON = "${chosenPython}/bin/python";
  nativeBuildInputs = [
    chosenPython
  ];

  # etc...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="i-see-the-bindgen-crate-constantly-rebuilding"><a class="header" href="#i-see-the-bindgen-crate-constantly-rebuilding">I see the <code>bindgen</code> crate constantly rebuilding</a></h2>
<p>If you are using <code>rustPlatform.bindgenHook</code> it is worth noting that it will
<a href="https://github.com/NixOS/nixpkgs/blob/3a73796bf2edb1dc026257da827678117ee7af57/pkgs/build-support/rust/hooks/rust-bindgen-hook.sh#L9">propagate <code>NIX_CFLAGS_COMPILE</code> via
<code>BINDGEN_EXTRA_CLANG_ARGS</code></a>.</p>
<p>In order to support reproducible builds, <a href="https://github.com/NixOS/nixpkgs/blob/c0b7a892fb042ede583bdaecbbdc804acb85eabe/pkgs/build-support/setup-hooks/reproducible-builds.sh#L6">this build hook will add
<code>-frandom-seed=...</code> to
<code>NIX_CFLAGS_COMPILE</code></a>
based on the current derivation's hash.</p>
<p>Since dependencies are built in a separate derivation as the main package, each
derivation essentially gets a different value for <code>-frandom-seed</code>. The <code>bindgen</code>
crate will <a href="https://github.com/rust-lang/rust-bindgen/blob/62859b2c6108c1c0f60d16b9ffe7544a4fbce48b/bindgen/build.rs#L20">observe this change and rebuild
itself</a>.</p>
<p>A workaround for this is to set <code>NIX_OUTPATH_USED_AS_RANDOM_SEED</code> to any
arbitrary 10 character string for <em>all derivations</em> which share artifacts
together.</p>
<pre><code class="language-nix">buildPackage {
  NIX_OUTPATH_USED_AS_RANDOM_SEED = "aaaaaaaaaa";
  # other attributes omitted
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="im-trying-to-build-another-cargo-project-from-source-which-has-no-lock-file"><a class="header" href="#im-trying-to-build-another-cargo-project-from-source-which-has-no-lock-file">I'm trying to build another cargo project from source which has no lock file</a></h2>
<p>First consider if there is a release of this project available <em>with</em> a lock
file as it may be simpler and more consistent to use the exact dependencies
published by the project itself. Projects published on crates.io always come
with a lock file and <code>nixpkgs</code> has a <code>fetchCrate</code> fetcher which pulls straight
from crates.io.</p>
<p>If that is not an option, the next best thing is to generate your own
<code>Cargo.lock</code> file and pass it in as an override by setting <code>cargoLock = ./path/to/Cargo.lock</code>. If you are calling <code>buildDepsOnly</code> or <code>vendorCargoDeps</code>
directly the value must be passed there; otherwise you can pass it into
<code>buildPackage</code> or <code>cargoBuild</code> and it will automatically passed through.</p>
<p>Note that the <code>Cargo.lock</code> file must be accessible <em>at evaluation time</em> for the
dependency vendoring to work, meaning the file cannot be generated within the
same derivation that builds the project. It <em>may</em> come from another derivation,
but it may require enabling IFD if flakes are not used.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="i-need-to-patch-cargolock-but-when-i-do-the-build-fails"><a class="header" href="#i-need-to-patch-cargolock-but-when-i-do-the-build-fails">I need to patch <code>Cargo.lock</code> but when I do the build fails</a></h2>
<p>Dependency crates are vendored by reading <code>Cargo.lock</code> <em>at evaluation time</em> and
not at build time. Thus using <code>patches = [ ./patch-which-updates-lockfile.patch ];</code>
may result in a situation where any new crates introduced by the patch cannot be
found by cargo.</p>
<p>It is possible to work around this limitation by patching <code>Cargo.lock</code> in a
stand-alone derivation and passing that result to <code>vendorCargoDeps</code> before
building the rest of the workspace.</p>
<pre><code class="language-nix">let
  patchedCargoLock = src = pkgs.stdenv.mkDerivation {
    src = ./path/to/Cargo.lock;
    patches = [
      ./update-cargo-lock.patch
    ];
    installPhase = ''
      runHook preInstall
      mkdir -p $out
      cp Cargo.lock $out
      runHook postInstall
    '';
  };
in
craneLib.buildPackage {
  cargoVendorDir = craneLib.vendorCargoDeps {
    src = patchedCargoLock;
  };

  src = craneLib.cleanCargoSource ./.;

  patches = [
    ./update-cargo-lock.patch
    ./some-other.patch
  ];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-can-i-build-only-a-subset-of-a-given-cargo-workspace"><a class="header" href="#how-can-i-build-only-a-subset-of-a-given-cargo-workspace">How can I build only a subset of a given cargo workspace?</a></h2>
<p>By default, cargo will build the crate at the current directory when invoked; if
the current directory holds a workspace, cargo will then build all crates within
that workspace.</p>
<p>Sometimes it can be useful to only build a subset of a given workspace (e.g.
only specific binaries are needed, or some crates cannot be built for certain
platforms, etc.), and cargo <a href="https://doc.rust-lang.org/cargo/commands/cargo-build.html">can be instructed to do so</a>.</p>
<p>Notably, it is possible to set:</p>
<ul>
<li><code>cargoExtraArgs = "-p foo -p bar";</code> to only build the <code>foo</code> and <code>bar</code> crates
only, but nothing else in the workspace</li>
<li><code>cargoExtraArgs = "--bin baz";</code> to only build the <code>baz</code> binary (from whatever
crate defines it)</li>
<li><code>cargoExtraArgs = "--workspace --exclude qux";</code> to build the entire cargo
workspace <em>except for the <code>qux</code> crate</em>.</li>
</ul>
<p>Consider setting <code>pname = "NAME_OF_THE_EXECUTABLE";</code> when building a single
executable from the workspace. Having the name of the package match the
executable name will allow the result to easily run via <code>nix run</code> without
further configuration.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="im-having-trouble-building-a-project-which-uses-include_str"><a class="header" href="#im-having-trouble-building-a-project-which-uses-include_str">I'm having trouble building a project which uses <code>include_str!</code></a></h2>
<p>Double check if the source passed into the derivation is being cleaned or
filtered in anyway. Using <code>craneLib.cleanCargoSource</code> (or
<code>craneLib.filterCargoSources</code> directly) will omit any non-cargo and non-rust
files before trying to build the derivation. Thus if the project is trying to
use <code>include_str!</code>, <code>include_bytes!</code>, or any other attempt at accessing such a
file you may need to tweak the source filter to ensure the files are included.</p>
<p>Check out the <a href="faq/../source-filtering.html">source filtering</a> section for more info!</p>
<p>Note that if the error is originating from a git-dependency, it <a href="faq/./git-dep-cannot-find-relative-path.html">may be a
problem with the upstream source
itself</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dealing-with-sandbox-unfriendly-build-scripts"><a class="header" href="#dealing-with-sandbox-unfriendly-build-scripts">Dealing with sandbox-unfriendly build scripts</a></h2>
<p>In general, most build scripts used by popular Rust projects are pretty good at
only attempting to write to cargo's output directory. But every once in a while
it is possible to find a build script somewhere deep in the dependency tree
which assumes it can happily write to any directory it wants to (i.e. wherever
its own sources happen to be present). For build scripts like these the best
long term approach is almost always to fix them upstream; <a href="https://doc.rust-lang.org/cargo/reference/build-script-examples.html#code-generation">cargo's own
documentation also warns against
this</a>:</p>
<blockquote>
<p>In general, build scripts should not modify any files outside of OUT_DIR. It
may seem fine on the first blush, but it does cause problems when you use such
crate as a dependency, because there's an implicit invariant that sources in
.cargo/registry should be immutable. cargo won't allow such scripts when
packaging.</p>
</blockquote>
<p>As a dire last resort it is possible to copy all vendored sources out of the
(read-only) Nix store and into a writable directory. Keep in mind that doing so
requires recursively copying <em>all sources of all crates</em> the project depends on
<em>during every single build</em>; it comes with a performance <em>and</em> energy cost, and
as such <strong>it is not recommended</strong>.</p>
<pre><code class="language-nix"># You have been warned
buildPackage {
  # other attributes omitted
  postPatch = ''
    mkdir -p "$TMPDIR/nix-vendor"
    cp -Lr "$cargoVendorDir" -T "$TMPDIR/nix-vendor"
    sed -i "s|$cargoVendorDir|$TMPDIR/nix-vendor/|g" "$TMPDIR/nix-vendor/config.toml"
    chmod -R +w "$TMPDIR/nix-vendor"
    cargoVendorDir="$TMPDIR/nix-vendor"
  '';
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-workspace-root-cargotoml-is-not-at-the-root-of-the-derivations-source"><a class="header" href="#cargo-workspace-root-cargotoml-is-not-at-the-root-of-the-derivations-source">Cargo workspace root (Cargo.toml) is not at the root of the derivation's source</a></h2>
<p>Most cargo projects have their <code>Cargo.toml</code> at the root of the source, but it's
still possible to build a project where the <code>Cargo.toml</code> file is nested in a
deeper directory:</p>
<pre><code class="language-nix"># Assuming that we have the following directory structure:
# ./flake.nix
# ./flake.lock
# ./nested
# ./nested/Cargo.toml
# ./nested/Cargo.lock
# ./nested/src/*.rs
craneLib.buildPackage {
 src = myLib.cleanCargoSource ./.;
 cargoLock = ./nested/Cargo.lock;
 cargoToml = ./nested/Cargo.toml;
 # Use a postUnpack hook to jump into our nested directory. This will work
 # regardless of what the unpacked source is named (i.e. will avoid hashes
 # when using the root path of a flake).
 #
 # The unpackPhase sets `$sourceRoot` to the directory that was unpacked
 # but unfortunately `postUnpack` runs before the directory is actually
 # changed so we'll do two things:
 # 1. Jump into the directory we want (replace `nested` with your directory)
 # 2. Overwrite the variable so when the default build scripts run they don't
 # end up changing to a different directory again
 postUnpack = ''
   cd $sourceRoot/nested
   sourceRoot="."
 '';
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="found-invalid-metadata-files-for-crate-errors"><a class="header" href="#found-invalid-metadata-files-for-crate-errors"><code>found invalid metadata files for crate</code> errors</a></h2>
<p>This error can occur when mixing components from two different Rust toolchains,
for example, using <code>clippy</code> with artifacts produced from a different cargo
version. Check the configuration for specifying the exact Rust toolchain to be
used in the build:</p>
<pre><code class="language-nix">let
  rustToolchainForPkgs = p: ...;
  rustToolchain = rustToolchainForPkgs pkgs;
in
# Incorrect usage, missing `clippy` override!
#(crane.mkLib pkgs).overrideScope (final: prev: {
#  rustc = rustToolchain;
#  cargo = rustToolchain;
#  rustfmt = rustToolchain;
#});

# Correct usage (`overrideToolchain` handles the details for us)
(crane.mkLib pkgs).overrideToolchain rustToolchainForPkgs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-git-dependency-fails-to-find-a-file-by-a-relative-path"><a class="header" href="#a-git-dependency-fails-to-find-a-file-by-a-relative-path">A git dependency fails to find a file by a relative path</a></h2>
<p>Sometimes various Rust projects are written in a way where a <a href="faq/./building-with-non-rust-includes.html">build script or
<code>include_str!</code> invocation</a> attempts to
read files outside of the crate's root, but this causes problems if such a
project is used as a git-dependency.</p>
<p>Normally when cargo downloads a package source from a registry like crates.io,
it extracts each crate into its own separate directory (even if the upstream
source is a workspace with multiple crates). This means that published crates
usually do not suffer from this situation, however, cargo handles git
dependencies in a different (i.e. inconsistent) manner: cargo will download the
entire git directory <em>but keep all files in place</em>, which means that those
crates <em>happen</em> to be able to rely on a file structure which matches the
upstream repo.</p>
<p>Crane implements source fetching by following the behavior of the <code>cargo vendor</code>
command: each crate (whether it comes from a registry or a git repo) is extracted
in a separate directory. Thus the problem of trying to locate files outside of
the crate's (not the <em>workspace's</em>) root directory can also be demonstrated by
calling <code>cargo vendor</code> and then following its instructions (normally copying
some configuration to <code>.cargo/config.toml</code>) and then building as normal.</p>
<p>If building like this after running <code>cargo vendor</code> <strong>succeeds but fails when
building with Crane</strong> please open an issue with a reproduction! However, if the
<strong>build fails even without Crane</strong> there are a few options to remedying the
problem:</p>
<ul>
<li>Consider reporting the situation to the upstream project and/or contributing a
change there. If the primary authors are not familiar with or users of either
Nix or Crane, consider explaining that their project cannot be used by anyone
who wants to vendor their sources (e.g. through using <code>cargo vendor</code>).</li>
<li>Consider forking the crate and remedying the problem there until it is
accepted upstream</li>
<li>Consider <a href="faq/../patching_dependency_sources.html">locally patching the dependency source while building with
Nix</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="controlling-whether-or-not-hooks-run-during-builddepsonly"><a class="header" href="#controlling-whether-or-not-hooks-run-during-builddepsonly">Controlling whether or not hooks run during <code>buildDepsOnly</code></a></h2>
<p>A typical project configuration will build a workspace's dependencies (without
the actual sources) during the <code>buildDepsOnly</code> derivation, and later build the
project's sources in a second derivation. Sometimes this results in problems if
a build hook is accidentally configured to run in both derivations but expects
to use the real sources, for example.</p>
<h3 id="solution-1-explicitly-configure-the-arguments-to-each-derivation"><a class="header" href="#solution-1-explicitly-configure-the-arguments-to-each-derivation">Solution 1: explicitly configure the arguments to each derivation</a></h3>
<pre><code class="language-nix">let
  # Explicitly split out common arguments
  commonArgs = {
    src = ./.;
    # etc.
  };

  # Then explicitly define the arguments to `buildDepsOnly`
  cargoArtifacts = craneLib.buildDepsOnly (commonArgs // {
    postConfigure = ''
      echo 'I am a hook which must only run during buildDepsOnly'
    '';
  });
};
in
craneLib.buildPackage (commonArgs // {
  inherit cargoArtifacts;
  preBuild = ''
    echo 'I am a hook which must run with the real sources'
  '';
})
</code></pre>
<h3 id="solution-2-check-whether-crane_build_deps_only-env-var-is-set"><a class="header" href="#solution-2-check-whether-crane_build_deps_only-env-var-is-set">Solution 2: check whether <code>CRANE_BUILD_DEPS_ONLY</code> env var is set</a></h3>
<blockquote>
<p>Note that with this approach, changing the build hook <em>will rebuild all
dependencies</em>, so consider the first solution above if possible.</p>
</blockquote>
<pre><code class="language-nix">craneLib.buildPackage {
  src = ./.;

  postConfigure = ''
    # NB: use ''${var} to escape the ${...} so that Nix does not interpet it as
    # an evaluation variable (since CRANE_BUILD_DEPS_ONLY is a shell variable)
    if [ -n "''${CRANE_BUILD_DEPS_ONLY:-}"]; then
      echo 'I am a hook which must only run during buildDepsOnly'
    fi
  '';

  preBuild = ''
    # NB: use ''${var} to escape the ${...} so that Nix does not interpet it as
    # an evaluation variable (since CRANE_BUILD_DEPS_ONLY is a shell variable)
    if [ -z "''${CRANE_BUILD_DEPS_ONLY:-}"]; then
      echo 'I am a hook which must run with the real sources'
    fi
  '';
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="missing-files-during-checks-when-filtering-with-filesets"><a class="header" href="#missing-files-during-checks-when-filtering-with-filesets">Missing files during <code>checks</code> when filtering with filesets</a></h2>
<p>One sanity check if you are running into <code>NotFound</code> errors for flake checks, is
to double check that the derivations built in <code>checks</code> have the appropriate
sources. Consider the following:</p>
<p>The <code>checks</code> attribute, which may have a <code>my-workspace-nextest</code> attribute that
runs <code>cargo-nextest</code>, for example, by default only needs the <code>commonArgs</code> and
<code>cargoArtifacts</code> in order to run tests. However, in cases where tests rely on
reading files, the <code>src</code> attribute can also be declared so that the files will
be included when the tests are run. This could also be true for checks like
<code>my-workspace-clippy</code>, if markdown files are included in rust doc comments.</p>
<pre><code class="language-nix">checks.my-workspace-nextest =
  let
    workspace.root = ./.;
    # Keep markdown files for doc generation, or compilation if using the
    # `include` rust macro.
    docSources = from: lib.fileset.fileFilter (file: file.hasExt "md") from;
    # Keep json files for testing.
    testDataSources = from: lib.fileset.fileFilter (file: file.hasExt "json") from;
  in
  craneLib.cargoNextest (buildArgs // {
    inherit cargoArtifacts;
    src = lib.fileset.toSource {
      inherit (workspace) root;
      fileset = lib.fileset.unions [
        ./Cargo.toml
        ./Cargo.lock
        ./src
        (craneLib.fileset.commonCargoSources workspace.root)
        (docSources workspace.root)
        (testDataSources workspace.root)
      ];
    };
    partitions = 1;
    partitionType = "count";
    cargoNextestExtraArgs = "--no-tests=warn";
  });
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="i-want-to-cross-compile-aws-lc-sys-to-windows-using-mingw"><a class="header" href="#i-want-to-cross-compile-aws-lc-sys-to-windows-using-mingw">I want to cross compile aws-lc-sys to windows using mingw</a></h2>
<p>In its C compilation process <code>aws-lc-sys</code> tries to compile small test
binaries to check compiler features or assert that certain compiler bugs are not present.
It also uses <code>cmake</code> and <code>nasm</code>. There are pre-assembled <code>nasm</code> objects available, however,
the script that is required to use them does not work due to an unpatched shebang.</p>
<p>It's especially challenging to include <code>aws-lc-sys</code> as a build dependency (or even worse,
both as build and normal dependency). When cross compiling, the environment by default
uses the cross compiler, which compiles windows binaries. This makes the test binaries
described earlier not work properly for the build-dependency build (can't properly execute
the windows binaries on linux).</p>
<p>To fix those issues, use the following options in your <code>craneLib.buildPackage</code> options:</p>
<pre><code class="language-nix">{
    # Assemble from source instead of using pre-assembled objects
    AWS_LC_SYS_PREBUILT_NASM = 0;
    # Ignore compiler warnings that cause windows cross-build to fail (because of -Werror)
    CFLAGS = "-Wno-stringop-overflow -Wno-array-bounds -Wno-restrict";
    # Fix missing &lt;pthread.h&gt; include
    CFLAGS_x86_64-pc-windows-gnu = "-I${pkgs.windows.mingw_w64_pthreads}/include"; # fix missing &lt;pthread.h&gt;
    # On linux, use linux cc/cxx (default in cross compilation stdenv is mingw)
    "CC_${buildPlatformSuffix}" = "cc";
    "CXX_${buildPlatformSuffix}" = "cc";

    # Make necessary build tools available
    nativeBuildInputs = with pkgs; [
        buildPackages.nasm
        buildPackages.cmake
    ];
}
</code></pre>
<p>In the flake below, you can find all the fixes needed for cross compilation to work, in nix build
and in a dev shell. This was tested with up to date flake inputs and cargo dependencies on July 21, 2025.
You can find a full demo project <a href="https://github.com/vypxl/nix-rust-windows">here</a>.</p>
<pre><code class="language-nix">{
  description = "Build a cargo project";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    crane.url = "github:ipetkov/crane";
    fenix = {
      url = "github:nix-community/fenix";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs =
    {
      self,
      nixpkgs,
      crane,
      fenix,
      flake-utils,
      ...
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = import nixpkgs {
          localSystem = system;
          crossSystem = {
            config = "x86_64-w64-mingw32";
            libc = "msvcrt";
          };
        };

        buildPlatformSuffix = pkgs.lib.strings.toLower pkgs.pkgsBuildHost.stdenv.hostPlatform.rust.cargoEnvVarTarget;

        toolchain =
          with fenix.packages.${system};
          combine [
            default.toolchain
            stable.rust-src
            targets.x86_64-pc-windows-gnu.latest.rust-std
          ];

        craneLib = (crane.mkLib pkgs).overrideToolchain (p: toolchain);

        src = craneLib.cleanCargoSource ./.;

        commonArgsWin = {
          inherit src;
          strictDeps = true;
          doCheck = false;

          CARGO_BUILD_TARGET = "x86_64-pc-windows-gnu";

          # fixes issues with aws-lc-sys
          AWS_LC_SYS_PREBUILT_NASM = 0; # just assemble it instead of using the prebuilt objects
          CFLAGS = "-Wno-stringop-overflow -Wno-array-bounds -Wno-restrict"; # ignore some warnings that pop up when cross compiling
          CFLAGS_x86_64-pc-windows-gnu = "-I${pkgs.windows.mingw_w64_pthreads}/include"; # fix missing &lt;pthread.h&gt;
          "CC_${buildPlatformSuffix}" = "cc"; # Make linux build use linux compiler (not mingw)
          "CXX_${buildPlatformSuffix}" = "cc";

          nativeBuildInputs = with pkgs; [
            buildPackages.nasm
            buildPackages.cmake
          ];
        };

        cargoArtifactsWin = craneLib.buildDepsOnly commonArgsWin;

        make-windows-crate =
          name:
          craneLib.buildPackage (
            commonArgsWin
            // {
              cargoArtifacts = cargoArtifactsWin;
              pname = name;
              cargoExtraArgs = "-p ${name}";
            }
          );
      in
      {
        packages = {
          default = make-windows-crate "yeet";
        };

        devShells.default = craneLib.devShell {
          packages = [
            pkgs.buildPackages.nasm
            pkgs.buildPackages.cmake
          ];
          buildInputs = [
            pkgs.windows.mingw_w64_pthreads
          ];

          CARGO_BUILD_TARGET = "x86_64-pc-windows-gnu";

          # fixes issues with aws-lc-sys
          AWS_LC_SYS_PREBUILT_NASM = 0;
          CFLAGS = "-Wno-stringop-overflow -Wno-array-bounds -Wno-restrict";
          "CC_${buildPlatformSuffix}" = "cc";
          "CXX_${buildPlatformSuffix}" = "cc";
        };
      }
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-techniques"><a class="header" href="#advanced-techniques">Advanced Techniques</a></h2>
<p>This chapter contains various "advanced" techniques for configuring
and modifying the behaviors of <code>crane</code>.</p>
<p>Most projects will likely not need to apply these patterns as they may require
extensive familiarity with Nix as well as <code>crane</code> internals.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="overriding-function-behavior"><a class="header" href="#overriding-function-behavior">Overriding function behavior</a></h2>
<p>At it's core, <code>crane</code> is instantiated via <code>pkgs.lib.newScope</code> which allows any
internal definition to be changed or replaced via <code>.overrideScope</code> (which
behaves very much like applying overlays to nixpkgs). Although this mechanism is
incredibly powerful, care should be taken to avoid creating confusing or brittle
integrations built on undocumented details.</p>
<p>Note that <code>crane</code>'s stability guarantees (with respect to semantic versioning) only
apply to what has been <a href="advanced/../API.html">documented at the API level</a>. For example,
<code>buildPackage</code> is documented to delegate to <code>mkCargoDerivation</code>, so any changes
or overrides to <code>mkCargoDerivation</code>'s behavior will be observed by
<code>buildPackage</code>. Other non-documented internal details, however, may change at
any time, so take care when reaching this deep into the internals.</p>
<p>Here is an example:</p>
<pre><code class="language-nix">let
  craneLib = (inputs.crane.mkLib pkgs).overrideScope (final: prev: {
    # We override the behavior of `mkCargoDerivation` by adding a wrapper which
    # will set a default value of `CARGO_PROFILE` when not set by the caller.
    # This change will automatically be propagated to any other functions built
    # on top of it (like `buildPackage`, `cargoBuild`, etc.)
    mkCargoDerivation = args: prev.mkCargoDerivation ({
      CARGO_PROFILE = "bench"; # E.g. always build in benchmark mode unless overridden
    } // args);
  });
in
{
    # Build two different workspaces with the modified behavior above

    foo = craneLib.buildPackage {
      src = craneLib.cleanCargoSource ./foo;
    };

    bar = craneLib.buildPackage {
      src = craneLib.cleanCargoSource ./bar;
    };
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
